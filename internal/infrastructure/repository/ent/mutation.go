// Code generated by ent, DO NOT EDIT.

package ent

import (
	"context"
	"errors"
	"fmt"
	"kiwi-user/internal/domain/model/entity"
	"kiwi-user/internal/infrastructure/repository/ent/application"
	"kiwi-user/internal/infrastructure/repository/ent/binding"
	"kiwi-user/internal/infrastructure/repository/ent/bindingverify"
	"kiwi-user/internal/infrastructure/repository/ent/device"
	"kiwi-user/internal/infrastructure/repository/ent/mailvertifycode"
	"kiwi-user/internal/infrastructure/repository/ent/organization"
	"kiwi-user/internal/infrastructure/repository/ent/organizationapplication"
	"kiwi-user/internal/infrastructure/repository/ent/organizationrequest"
	"kiwi-user/internal/infrastructure/repository/ent/organizationuser"
	"kiwi-user/internal/infrastructure/repository/ent/payment"
	"kiwi-user/internal/infrastructure/repository/ent/predicate"
	"kiwi-user/internal/infrastructure/repository/ent/qywechatuserid"
	"kiwi-user/internal/infrastructure/repository/ent/role"
	"kiwi-user/internal/infrastructure/repository/ent/scope"
	"kiwi-user/internal/infrastructure/repository/ent/user"
	"kiwi-user/internal/infrastructure/repository/ent/wechatopenid"
	"sync"
	"time"

	"entgo.io/ent"
	"entgo.io/ent/dialect/sql"
	"github.com/google/uuid"
)

const (
	// Operation types.
	OpCreate    = ent.OpCreate
	OpDelete    = ent.OpDelete
	OpDeleteOne = ent.OpDeleteOne
	OpUpdate    = ent.OpUpdate
	OpUpdateOne = ent.OpUpdateOne

	// Node types.
	TypeApplication             = "Application"
	TypeBinding                 = "Binding"
	TypeBindingVerify           = "BindingVerify"
	TypeDevice                  = "Device"
	TypeMailVertifyCode         = "MailVertifyCode"
	TypeOrganization            = "Organization"
	TypeOrganizationApplication = "OrganizationApplication"
	TypeOrganizationRequest     = "OrganizationRequest"
	TypeOrganizationUser        = "OrganizationUser"
	TypePayment                 = "Payment"
	TypeQyWechatUserID          = "QyWechatUserID"
	TypeRole                    = "Role"
	TypeScope                   = "Scope"
	TypeUser                    = "User"
	TypeWechatOpenID            = "WechatOpenID"
)

// ApplicationMutation represents an operation that mutates the Application nodes in the graph.
type ApplicationMutation struct {
	config
	op                              Op
	typ                             string
	id                              *uuid.UUID
	created_at                      *time.Time
	updated_at                      *time.Time
	deleted_at                      *time.Time
	name                            *string
	clearedFields                   map[string]struct{}
	users                           map[string]struct{}
	removedusers                    map[string]struct{}
	clearedusers                    bool
	organizations                   map[uuid.UUID]struct{}
	removedorganizations            map[uuid.UUID]struct{}
	clearedorganizations            bool
	roles                           map[uuid.UUID]struct{}
	removedroles                    map[uuid.UUID]struct{}
	clearedroles                    bool
	default_personal_role           *uuid.UUID
	cleareddefault_personal_role    bool
	default_org_role                *uuid.UUID
	cleareddefault_org_role         bool
	default_org_admin_role          *uuid.UUID
	cleareddefault_org_admin_role   bool
	organization_application        map[uuid.UUID]struct{}
	removedorganization_application map[uuid.UUID]struct{}
	clearedorganization_application bool
	done                            bool
	oldValue                        func(context.Context) (*Application, error)
	predicates                      []predicate.Application
}

var _ ent.Mutation = (*ApplicationMutation)(nil)

// applicationOption allows management of the mutation configuration using functional options.
type applicationOption func(*ApplicationMutation)

// newApplicationMutation creates new mutation for the Application entity.
func newApplicationMutation(c config, op Op, opts ...applicationOption) *ApplicationMutation {
	m := &ApplicationMutation{
		config:        c,
		op:            op,
		typ:           TypeApplication,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withApplicationID sets the ID field of the mutation.
func withApplicationID(id uuid.UUID) applicationOption {
	return func(m *ApplicationMutation) {
		var (
			err   error
			once  sync.Once
			value *Application
		)
		m.oldValue = func(ctx context.Context) (*Application, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Application.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withApplication sets the old Application of the mutation.
func withApplication(node *Application) applicationOption {
	return func(m *ApplicationMutation) {
		m.oldValue = func(context.Context) (*Application, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ApplicationMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ApplicationMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Application entities.
func (m *ApplicationMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ApplicationMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ApplicationMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Application.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *ApplicationMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *ApplicationMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Application entity.
// If the Application object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ApplicationMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *ApplicationMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *ApplicationMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *ApplicationMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Application entity.
// If the Application object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ApplicationMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *ApplicationMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *ApplicationMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *ApplicationMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the Application entity.
// If the Application object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ApplicationMutation) OldDeletedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *ApplicationMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[application.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *ApplicationMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[application.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *ApplicationMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, application.FieldDeletedAt)
}

// SetName sets the "name" field.
func (m *ApplicationMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *ApplicationMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Application entity.
// If the Application object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ApplicationMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *ApplicationMutation) ResetName() {
	m.name = nil
}

// AddUserIDs adds the "users" edge to the User entity by ids.
func (m *ApplicationMutation) AddUserIDs(ids ...string) {
	if m.users == nil {
		m.users = make(map[string]struct{})
	}
	for i := range ids {
		m.users[ids[i]] = struct{}{}
	}
}

// ClearUsers clears the "users" edge to the User entity.
func (m *ApplicationMutation) ClearUsers() {
	m.clearedusers = true
}

// UsersCleared reports if the "users" edge to the User entity was cleared.
func (m *ApplicationMutation) UsersCleared() bool {
	return m.clearedusers
}

// RemoveUserIDs removes the "users" edge to the User entity by IDs.
func (m *ApplicationMutation) RemoveUserIDs(ids ...string) {
	if m.removedusers == nil {
		m.removedusers = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.users, ids[i])
		m.removedusers[ids[i]] = struct{}{}
	}
}

// RemovedUsers returns the removed IDs of the "users" edge to the User entity.
func (m *ApplicationMutation) RemovedUsersIDs() (ids []string) {
	for id := range m.removedusers {
		ids = append(ids, id)
	}
	return
}

// UsersIDs returns the "users" edge IDs in the mutation.
func (m *ApplicationMutation) UsersIDs() (ids []string) {
	for id := range m.users {
		ids = append(ids, id)
	}
	return
}

// ResetUsers resets all changes to the "users" edge.
func (m *ApplicationMutation) ResetUsers() {
	m.users = nil
	m.clearedusers = false
	m.removedusers = nil
}

// AddOrganizationIDs adds the "organizations" edge to the Organization entity by ids.
func (m *ApplicationMutation) AddOrganizationIDs(ids ...uuid.UUID) {
	if m.organizations == nil {
		m.organizations = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.organizations[ids[i]] = struct{}{}
	}
}

// ClearOrganizations clears the "organizations" edge to the Organization entity.
func (m *ApplicationMutation) ClearOrganizations() {
	m.clearedorganizations = true
}

// OrganizationsCleared reports if the "organizations" edge to the Organization entity was cleared.
func (m *ApplicationMutation) OrganizationsCleared() bool {
	return m.clearedorganizations
}

// RemoveOrganizationIDs removes the "organizations" edge to the Organization entity by IDs.
func (m *ApplicationMutation) RemoveOrganizationIDs(ids ...uuid.UUID) {
	if m.removedorganizations == nil {
		m.removedorganizations = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.organizations, ids[i])
		m.removedorganizations[ids[i]] = struct{}{}
	}
}

// RemovedOrganizations returns the removed IDs of the "organizations" edge to the Organization entity.
func (m *ApplicationMutation) RemovedOrganizationsIDs() (ids []uuid.UUID) {
	for id := range m.removedorganizations {
		ids = append(ids, id)
	}
	return
}

// OrganizationsIDs returns the "organizations" edge IDs in the mutation.
func (m *ApplicationMutation) OrganizationsIDs() (ids []uuid.UUID) {
	for id := range m.organizations {
		ids = append(ids, id)
	}
	return
}

// ResetOrganizations resets all changes to the "organizations" edge.
func (m *ApplicationMutation) ResetOrganizations() {
	m.organizations = nil
	m.clearedorganizations = false
	m.removedorganizations = nil
}

// AddRoleIDs adds the "roles" edge to the Role entity by ids.
func (m *ApplicationMutation) AddRoleIDs(ids ...uuid.UUID) {
	if m.roles == nil {
		m.roles = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.roles[ids[i]] = struct{}{}
	}
}

// ClearRoles clears the "roles" edge to the Role entity.
func (m *ApplicationMutation) ClearRoles() {
	m.clearedroles = true
}

// RolesCleared reports if the "roles" edge to the Role entity was cleared.
func (m *ApplicationMutation) RolesCleared() bool {
	return m.clearedroles
}

// RemoveRoleIDs removes the "roles" edge to the Role entity by IDs.
func (m *ApplicationMutation) RemoveRoleIDs(ids ...uuid.UUID) {
	if m.removedroles == nil {
		m.removedroles = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.roles, ids[i])
		m.removedroles[ids[i]] = struct{}{}
	}
}

// RemovedRoles returns the removed IDs of the "roles" edge to the Role entity.
func (m *ApplicationMutation) RemovedRolesIDs() (ids []uuid.UUID) {
	for id := range m.removedroles {
		ids = append(ids, id)
	}
	return
}

// RolesIDs returns the "roles" edge IDs in the mutation.
func (m *ApplicationMutation) RolesIDs() (ids []uuid.UUID) {
	for id := range m.roles {
		ids = append(ids, id)
	}
	return
}

// ResetRoles resets all changes to the "roles" edge.
func (m *ApplicationMutation) ResetRoles() {
	m.roles = nil
	m.clearedroles = false
	m.removedroles = nil
}

// SetDefaultPersonalRoleID sets the "default_personal_role" edge to the Role entity by id.
func (m *ApplicationMutation) SetDefaultPersonalRoleID(id uuid.UUID) {
	m.default_personal_role = &id
}

// ClearDefaultPersonalRole clears the "default_personal_role" edge to the Role entity.
func (m *ApplicationMutation) ClearDefaultPersonalRole() {
	m.cleareddefault_personal_role = true
}

// DefaultPersonalRoleCleared reports if the "default_personal_role" edge to the Role entity was cleared.
func (m *ApplicationMutation) DefaultPersonalRoleCleared() bool {
	return m.cleareddefault_personal_role
}

// DefaultPersonalRoleID returns the "default_personal_role" edge ID in the mutation.
func (m *ApplicationMutation) DefaultPersonalRoleID() (id uuid.UUID, exists bool) {
	if m.default_personal_role != nil {
		return *m.default_personal_role, true
	}
	return
}

// DefaultPersonalRoleIDs returns the "default_personal_role" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// DefaultPersonalRoleID instead. It exists only for internal usage by the builders.
func (m *ApplicationMutation) DefaultPersonalRoleIDs() (ids []uuid.UUID) {
	if id := m.default_personal_role; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetDefaultPersonalRole resets all changes to the "default_personal_role" edge.
func (m *ApplicationMutation) ResetDefaultPersonalRole() {
	m.default_personal_role = nil
	m.cleareddefault_personal_role = false
}

// SetDefaultOrgRoleID sets the "default_org_role" edge to the Role entity by id.
func (m *ApplicationMutation) SetDefaultOrgRoleID(id uuid.UUID) {
	m.default_org_role = &id
}

// ClearDefaultOrgRole clears the "default_org_role" edge to the Role entity.
func (m *ApplicationMutation) ClearDefaultOrgRole() {
	m.cleareddefault_org_role = true
}

// DefaultOrgRoleCleared reports if the "default_org_role" edge to the Role entity was cleared.
func (m *ApplicationMutation) DefaultOrgRoleCleared() bool {
	return m.cleareddefault_org_role
}

// DefaultOrgRoleID returns the "default_org_role" edge ID in the mutation.
func (m *ApplicationMutation) DefaultOrgRoleID() (id uuid.UUID, exists bool) {
	if m.default_org_role != nil {
		return *m.default_org_role, true
	}
	return
}

// DefaultOrgRoleIDs returns the "default_org_role" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// DefaultOrgRoleID instead. It exists only for internal usage by the builders.
func (m *ApplicationMutation) DefaultOrgRoleIDs() (ids []uuid.UUID) {
	if id := m.default_org_role; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetDefaultOrgRole resets all changes to the "default_org_role" edge.
func (m *ApplicationMutation) ResetDefaultOrgRole() {
	m.default_org_role = nil
	m.cleareddefault_org_role = false
}

// SetDefaultOrgAdminRoleID sets the "default_org_admin_role" edge to the Role entity by id.
func (m *ApplicationMutation) SetDefaultOrgAdminRoleID(id uuid.UUID) {
	m.default_org_admin_role = &id
}

// ClearDefaultOrgAdminRole clears the "default_org_admin_role" edge to the Role entity.
func (m *ApplicationMutation) ClearDefaultOrgAdminRole() {
	m.cleareddefault_org_admin_role = true
}

// DefaultOrgAdminRoleCleared reports if the "default_org_admin_role" edge to the Role entity was cleared.
func (m *ApplicationMutation) DefaultOrgAdminRoleCleared() bool {
	return m.cleareddefault_org_admin_role
}

// DefaultOrgAdminRoleID returns the "default_org_admin_role" edge ID in the mutation.
func (m *ApplicationMutation) DefaultOrgAdminRoleID() (id uuid.UUID, exists bool) {
	if m.default_org_admin_role != nil {
		return *m.default_org_admin_role, true
	}
	return
}

// DefaultOrgAdminRoleIDs returns the "default_org_admin_role" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// DefaultOrgAdminRoleID instead. It exists only for internal usage by the builders.
func (m *ApplicationMutation) DefaultOrgAdminRoleIDs() (ids []uuid.UUID) {
	if id := m.default_org_admin_role; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetDefaultOrgAdminRole resets all changes to the "default_org_admin_role" edge.
func (m *ApplicationMutation) ResetDefaultOrgAdminRole() {
	m.default_org_admin_role = nil
	m.cleareddefault_org_admin_role = false
}

// AddOrganizationApplicationIDs adds the "organization_application" edge to the OrganizationApplication entity by ids.
func (m *ApplicationMutation) AddOrganizationApplicationIDs(ids ...uuid.UUID) {
	if m.organization_application == nil {
		m.organization_application = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.organization_application[ids[i]] = struct{}{}
	}
}

// ClearOrganizationApplication clears the "organization_application" edge to the OrganizationApplication entity.
func (m *ApplicationMutation) ClearOrganizationApplication() {
	m.clearedorganization_application = true
}

// OrganizationApplicationCleared reports if the "organization_application" edge to the OrganizationApplication entity was cleared.
func (m *ApplicationMutation) OrganizationApplicationCleared() bool {
	return m.clearedorganization_application
}

// RemoveOrganizationApplicationIDs removes the "organization_application" edge to the OrganizationApplication entity by IDs.
func (m *ApplicationMutation) RemoveOrganizationApplicationIDs(ids ...uuid.UUID) {
	if m.removedorganization_application == nil {
		m.removedorganization_application = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.organization_application, ids[i])
		m.removedorganization_application[ids[i]] = struct{}{}
	}
}

// RemovedOrganizationApplication returns the removed IDs of the "organization_application" edge to the OrganizationApplication entity.
func (m *ApplicationMutation) RemovedOrganizationApplicationIDs() (ids []uuid.UUID) {
	for id := range m.removedorganization_application {
		ids = append(ids, id)
	}
	return
}

// OrganizationApplicationIDs returns the "organization_application" edge IDs in the mutation.
func (m *ApplicationMutation) OrganizationApplicationIDs() (ids []uuid.UUID) {
	for id := range m.organization_application {
		ids = append(ids, id)
	}
	return
}

// ResetOrganizationApplication resets all changes to the "organization_application" edge.
func (m *ApplicationMutation) ResetOrganizationApplication() {
	m.organization_application = nil
	m.clearedorganization_application = false
	m.removedorganization_application = nil
}

// Where appends a list predicates to the ApplicationMutation builder.
func (m *ApplicationMutation) Where(ps ...predicate.Application) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ApplicationMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ApplicationMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Application, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ApplicationMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ApplicationMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Application).
func (m *ApplicationMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ApplicationMutation) Fields() []string {
	fields := make([]string, 0, 4)
	if m.created_at != nil {
		fields = append(fields, application.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, application.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, application.FieldDeletedAt)
	}
	if m.name != nil {
		fields = append(fields, application.FieldName)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ApplicationMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case application.FieldCreatedAt:
		return m.CreatedAt()
	case application.FieldUpdatedAt:
		return m.UpdatedAt()
	case application.FieldDeletedAt:
		return m.DeletedAt()
	case application.FieldName:
		return m.Name()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ApplicationMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case application.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case application.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case application.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case application.FieldName:
		return m.OldName(ctx)
	}
	return nil, fmt.Errorf("unknown Application field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ApplicationMutation) SetField(name string, value ent.Value) error {
	switch name {
	case application.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case application.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case application.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case application.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	}
	return fmt.Errorf("unknown Application field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ApplicationMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ApplicationMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ApplicationMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Application numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ApplicationMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(application.FieldDeletedAt) {
		fields = append(fields, application.FieldDeletedAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ApplicationMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ApplicationMutation) ClearField(name string) error {
	switch name {
	case application.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	}
	return fmt.Errorf("unknown Application nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ApplicationMutation) ResetField(name string) error {
	switch name {
	case application.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case application.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case application.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case application.FieldName:
		m.ResetName()
		return nil
	}
	return fmt.Errorf("unknown Application field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ApplicationMutation) AddedEdges() []string {
	edges := make([]string, 0, 7)
	if m.users != nil {
		edges = append(edges, application.EdgeUsers)
	}
	if m.organizations != nil {
		edges = append(edges, application.EdgeOrganizations)
	}
	if m.roles != nil {
		edges = append(edges, application.EdgeRoles)
	}
	if m.default_personal_role != nil {
		edges = append(edges, application.EdgeDefaultPersonalRole)
	}
	if m.default_org_role != nil {
		edges = append(edges, application.EdgeDefaultOrgRole)
	}
	if m.default_org_admin_role != nil {
		edges = append(edges, application.EdgeDefaultOrgAdminRole)
	}
	if m.organization_application != nil {
		edges = append(edges, application.EdgeOrganizationApplication)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ApplicationMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case application.EdgeUsers:
		ids := make([]ent.Value, 0, len(m.users))
		for id := range m.users {
			ids = append(ids, id)
		}
		return ids
	case application.EdgeOrganizations:
		ids := make([]ent.Value, 0, len(m.organizations))
		for id := range m.organizations {
			ids = append(ids, id)
		}
		return ids
	case application.EdgeRoles:
		ids := make([]ent.Value, 0, len(m.roles))
		for id := range m.roles {
			ids = append(ids, id)
		}
		return ids
	case application.EdgeDefaultPersonalRole:
		if id := m.default_personal_role; id != nil {
			return []ent.Value{*id}
		}
	case application.EdgeDefaultOrgRole:
		if id := m.default_org_role; id != nil {
			return []ent.Value{*id}
		}
	case application.EdgeDefaultOrgAdminRole:
		if id := m.default_org_admin_role; id != nil {
			return []ent.Value{*id}
		}
	case application.EdgeOrganizationApplication:
		ids := make([]ent.Value, 0, len(m.organization_application))
		for id := range m.organization_application {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ApplicationMutation) RemovedEdges() []string {
	edges := make([]string, 0, 7)
	if m.removedusers != nil {
		edges = append(edges, application.EdgeUsers)
	}
	if m.removedorganizations != nil {
		edges = append(edges, application.EdgeOrganizations)
	}
	if m.removedroles != nil {
		edges = append(edges, application.EdgeRoles)
	}
	if m.removedorganization_application != nil {
		edges = append(edges, application.EdgeOrganizationApplication)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ApplicationMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case application.EdgeUsers:
		ids := make([]ent.Value, 0, len(m.removedusers))
		for id := range m.removedusers {
			ids = append(ids, id)
		}
		return ids
	case application.EdgeOrganizations:
		ids := make([]ent.Value, 0, len(m.removedorganizations))
		for id := range m.removedorganizations {
			ids = append(ids, id)
		}
		return ids
	case application.EdgeRoles:
		ids := make([]ent.Value, 0, len(m.removedroles))
		for id := range m.removedroles {
			ids = append(ids, id)
		}
		return ids
	case application.EdgeOrganizationApplication:
		ids := make([]ent.Value, 0, len(m.removedorganization_application))
		for id := range m.removedorganization_application {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ApplicationMutation) ClearedEdges() []string {
	edges := make([]string, 0, 7)
	if m.clearedusers {
		edges = append(edges, application.EdgeUsers)
	}
	if m.clearedorganizations {
		edges = append(edges, application.EdgeOrganizations)
	}
	if m.clearedroles {
		edges = append(edges, application.EdgeRoles)
	}
	if m.cleareddefault_personal_role {
		edges = append(edges, application.EdgeDefaultPersonalRole)
	}
	if m.cleareddefault_org_role {
		edges = append(edges, application.EdgeDefaultOrgRole)
	}
	if m.cleareddefault_org_admin_role {
		edges = append(edges, application.EdgeDefaultOrgAdminRole)
	}
	if m.clearedorganization_application {
		edges = append(edges, application.EdgeOrganizationApplication)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ApplicationMutation) EdgeCleared(name string) bool {
	switch name {
	case application.EdgeUsers:
		return m.clearedusers
	case application.EdgeOrganizations:
		return m.clearedorganizations
	case application.EdgeRoles:
		return m.clearedroles
	case application.EdgeDefaultPersonalRole:
		return m.cleareddefault_personal_role
	case application.EdgeDefaultOrgRole:
		return m.cleareddefault_org_role
	case application.EdgeDefaultOrgAdminRole:
		return m.cleareddefault_org_admin_role
	case application.EdgeOrganizationApplication:
		return m.clearedorganization_application
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ApplicationMutation) ClearEdge(name string) error {
	switch name {
	case application.EdgeDefaultPersonalRole:
		m.ClearDefaultPersonalRole()
		return nil
	case application.EdgeDefaultOrgRole:
		m.ClearDefaultOrgRole()
		return nil
	case application.EdgeDefaultOrgAdminRole:
		m.ClearDefaultOrgAdminRole()
		return nil
	}
	return fmt.Errorf("unknown Application unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ApplicationMutation) ResetEdge(name string) error {
	switch name {
	case application.EdgeUsers:
		m.ResetUsers()
		return nil
	case application.EdgeOrganizations:
		m.ResetOrganizations()
		return nil
	case application.EdgeRoles:
		m.ResetRoles()
		return nil
	case application.EdgeDefaultPersonalRole:
		m.ResetDefaultPersonalRole()
		return nil
	case application.EdgeDefaultOrgRole:
		m.ResetDefaultOrgRole()
		return nil
	case application.EdgeDefaultOrgAdminRole:
		m.ResetDefaultOrgAdminRole()
		return nil
	case application.EdgeOrganizationApplication:
		m.ResetOrganizationApplication()
		return nil
	}
	return fmt.Errorf("unknown Application edge %s", name)
}

// BindingMutation represents an operation that mutates the Binding nodes in the graph.
type BindingMutation struct {
	config
	op             Op
	typ            string
	id             *uuid.UUID
	created_at     *time.Time
	updated_at     *time.Time
	deleted_at     *time.Time
	_type          *binding.Type
	identity       *string
	verified       *bool
	salt           *string
	application_id *uuid.UUID
	clearedFields  map[string]struct{}
	user           *string
	cleareduser    bool
	done           bool
	oldValue       func(context.Context) (*Binding, error)
	predicates     []predicate.Binding
}

var _ ent.Mutation = (*BindingMutation)(nil)

// bindingOption allows management of the mutation configuration using functional options.
type bindingOption func(*BindingMutation)

// newBindingMutation creates new mutation for the Binding entity.
func newBindingMutation(c config, op Op, opts ...bindingOption) *BindingMutation {
	m := &BindingMutation{
		config:        c,
		op:            op,
		typ:           TypeBinding,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withBindingID sets the ID field of the mutation.
func withBindingID(id uuid.UUID) bindingOption {
	return func(m *BindingMutation) {
		var (
			err   error
			once  sync.Once
			value *Binding
		)
		m.oldValue = func(ctx context.Context) (*Binding, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Binding.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withBinding sets the old Binding of the mutation.
func withBinding(node *Binding) bindingOption {
	return func(m *BindingMutation) {
		m.oldValue = func(context.Context) (*Binding, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m BindingMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m BindingMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Binding entities.
func (m *BindingMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *BindingMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *BindingMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Binding.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *BindingMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *BindingMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Binding entity.
// If the Binding object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BindingMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *BindingMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *BindingMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *BindingMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Binding entity.
// If the Binding object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BindingMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *BindingMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *BindingMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *BindingMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the Binding entity.
// If the Binding object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BindingMutation) OldDeletedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *BindingMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[binding.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *BindingMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[binding.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *BindingMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, binding.FieldDeletedAt)
}

// SetType sets the "type" field.
func (m *BindingMutation) SetType(b binding.Type) {
	m._type = &b
}

// GetType returns the value of the "type" field in the mutation.
func (m *BindingMutation) GetType() (r binding.Type, exists bool) {
	v := m._type
	if v == nil {
		return
	}
	return *v, true
}

// OldType returns the old "type" field's value of the Binding entity.
// If the Binding object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BindingMutation) OldType(ctx context.Context) (v binding.Type, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldType: %w", err)
	}
	return oldValue.Type, nil
}

// ResetType resets all changes to the "type" field.
func (m *BindingMutation) ResetType() {
	m._type = nil
}

// SetIdentity sets the "identity" field.
func (m *BindingMutation) SetIdentity(s string) {
	m.identity = &s
}

// Identity returns the value of the "identity" field in the mutation.
func (m *BindingMutation) Identity() (r string, exists bool) {
	v := m.identity
	if v == nil {
		return
	}
	return *v, true
}

// OldIdentity returns the old "identity" field's value of the Binding entity.
// If the Binding object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BindingMutation) OldIdentity(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIdentity is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIdentity requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIdentity: %w", err)
	}
	return oldValue.Identity, nil
}

// ResetIdentity resets all changes to the "identity" field.
func (m *BindingMutation) ResetIdentity() {
	m.identity = nil
}

// SetVerified sets the "verified" field.
func (m *BindingMutation) SetVerified(b bool) {
	m.verified = &b
}

// Verified returns the value of the "verified" field in the mutation.
func (m *BindingMutation) Verified() (r bool, exists bool) {
	v := m.verified
	if v == nil {
		return
	}
	return *v, true
}

// OldVerified returns the old "verified" field's value of the Binding entity.
// If the Binding object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BindingMutation) OldVerified(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldVerified is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldVerified requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldVerified: %w", err)
	}
	return oldValue.Verified, nil
}

// ResetVerified resets all changes to the "verified" field.
func (m *BindingMutation) ResetVerified() {
	m.verified = nil
}

// SetSalt sets the "salt" field.
func (m *BindingMutation) SetSalt(s string) {
	m.salt = &s
}

// Salt returns the value of the "salt" field in the mutation.
func (m *BindingMutation) Salt() (r string, exists bool) {
	v := m.salt
	if v == nil {
		return
	}
	return *v, true
}

// OldSalt returns the old "salt" field's value of the Binding entity.
// If the Binding object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BindingMutation) OldSalt(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSalt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSalt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSalt: %w", err)
	}
	return oldValue.Salt, nil
}

// ClearSalt clears the value of the "salt" field.
func (m *BindingMutation) ClearSalt() {
	m.salt = nil
	m.clearedFields[binding.FieldSalt] = struct{}{}
}

// SaltCleared returns if the "salt" field was cleared in this mutation.
func (m *BindingMutation) SaltCleared() bool {
	_, ok := m.clearedFields[binding.FieldSalt]
	return ok
}

// ResetSalt resets all changes to the "salt" field.
func (m *BindingMutation) ResetSalt() {
	m.salt = nil
	delete(m.clearedFields, binding.FieldSalt)
}

// SetUserID sets the "user_id" field.
func (m *BindingMutation) SetUserID(s string) {
	m.user = &s
}

// UserID returns the value of the "user_id" field in the mutation.
func (m *BindingMutation) UserID() (r string, exists bool) {
	v := m.user
	if v == nil {
		return
	}
	return *v, true
}

// OldUserID returns the old "user_id" field's value of the Binding entity.
// If the Binding object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BindingMutation) OldUserID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserID: %w", err)
	}
	return oldValue.UserID, nil
}

// ResetUserID resets all changes to the "user_id" field.
func (m *BindingMutation) ResetUserID() {
	m.user = nil
}

// SetApplicationID sets the "application_id" field.
func (m *BindingMutation) SetApplicationID(u uuid.UUID) {
	m.application_id = &u
}

// ApplicationID returns the value of the "application_id" field in the mutation.
func (m *BindingMutation) ApplicationID() (r uuid.UUID, exists bool) {
	v := m.application_id
	if v == nil {
		return
	}
	return *v, true
}

// OldApplicationID returns the old "application_id" field's value of the Binding entity.
// If the Binding object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BindingMutation) OldApplicationID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldApplicationID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldApplicationID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldApplicationID: %w", err)
	}
	return oldValue.ApplicationID, nil
}

// ClearApplicationID clears the value of the "application_id" field.
func (m *BindingMutation) ClearApplicationID() {
	m.application_id = nil
	m.clearedFields[binding.FieldApplicationID] = struct{}{}
}

// ApplicationIDCleared returns if the "application_id" field was cleared in this mutation.
func (m *BindingMutation) ApplicationIDCleared() bool {
	_, ok := m.clearedFields[binding.FieldApplicationID]
	return ok
}

// ResetApplicationID resets all changes to the "application_id" field.
func (m *BindingMutation) ResetApplicationID() {
	m.application_id = nil
	delete(m.clearedFields, binding.FieldApplicationID)
}

// ClearUser clears the "user" edge to the User entity.
func (m *BindingMutation) ClearUser() {
	m.cleareduser = true
	m.clearedFields[binding.FieldUserID] = struct{}{}
}

// UserCleared reports if the "user" edge to the User entity was cleared.
func (m *BindingMutation) UserCleared() bool {
	return m.cleareduser
}

// UserIDs returns the "user" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UserID instead. It exists only for internal usage by the builders.
func (m *BindingMutation) UserIDs() (ids []string) {
	if id := m.user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUser resets all changes to the "user" edge.
func (m *BindingMutation) ResetUser() {
	m.user = nil
	m.cleareduser = false
}

// Where appends a list predicates to the BindingMutation builder.
func (m *BindingMutation) Where(ps ...predicate.Binding) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the BindingMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *BindingMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Binding, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *BindingMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *BindingMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Binding).
func (m *BindingMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *BindingMutation) Fields() []string {
	fields := make([]string, 0, 9)
	if m.created_at != nil {
		fields = append(fields, binding.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, binding.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, binding.FieldDeletedAt)
	}
	if m._type != nil {
		fields = append(fields, binding.FieldType)
	}
	if m.identity != nil {
		fields = append(fields, binding.FieldIdentity)
	}
	if m.verified != nil {
		fields = append(fields, binding.FieldVerified)
	}
	if m.salt != nil {
		fields = append(fields, binding.FieldSalt)
	}
	if m.user != nil {
		fields = append(fields, binding.FieldUserID)
	}
	if m.application_id != nil {
		fields = append(fields, binding.FieldApplicationID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *BindingMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case binding.FieldCreatedAt:
		return m.CreatedAt()
	case binding.FieldUpdatedAt:
		return m.UpdatedAt()
	case binding.FieldDeletedAt:
		return m.DeletedAt()
	case binding.FieldType:
		return m.GetType()
	case binding.FieldIdentity:
		return m.Identity()
	case binding.FieldVerified:
		return m.Verified()
	case binding.FieldSalt:
		return m.Salt()
	case binding.FieldUserID:
		return m.UserID()
	case binding.FieldApplicationID:
		return m.ApplicationID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *BindingMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case binding.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case binding.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case binding.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case binding.FieldType:
		return m.OldType(ctx)
	case binding.FieldIdentity:
		return m.OldIdentity(ctx)
	case binding.FieldVerified:
		return m.OldVerified(ctx)
	case binding.FieldSalt:
		return m.OldSalt(ctx)
	case binding.FieldUserID:
		return m.OldUserID(ctx)
	case binding.FieldApplicationID:
		return m.OldApplicationID(ctx)
	}
	return nil, fmt.Errorf("unknown Binding field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *BindingMutation) SetField(name string, value ent.Value) error {
	switch name {
	case binding.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case binding.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case binding.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case binding.FieldType:
		v, ok := value.(binding.Type)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetType(v)
		return nil
	case binding.FieldIdentity:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIdentity(v)
		return nil
	case binding.FieldVerified:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetVerified(v)
		return nil
	case binding.FieldSalt:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSalt(v)
		return nil
	case binding.FieldUserID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserID(v)
		return nil
	case binding.FieldApplicationID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetApplicationID(v)
		return nil
	}
	return fmt.Errorf("unknown Binding field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *BindingMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *BindingMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *BindingMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Binding numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *BindingMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(binding.FieldDeletedAt) {
		fields = append(fields, binding.FieldDeletedAt)
	}
	if m.FieldCleared(binding.FieldSalt) {
		fields = append(fields, binding.FieldSalt)
	}
	if m.FieldCleared(binding.FieldApplicationID) {
		fields = append(fields, binding.FieldApplicationID)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *BindingMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *BindingMutation) ClearField(name string) error {
	switch name {
	case binding.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case binding.FieldSalt:
		m.ClearSalt()
		return nil
	case binding.FieldApplicationID:
		m.ClearApplicationID()
		return nil
	}
	return fmt.Errorf("unknown Binding nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *BindingMutation) ResetField(name string) error {
	switch name {
	case binding.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case binding.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case binding.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case binding.FieldType:
		m.ResetType()
		return nil
	case binding.FieldIdentity:
		m.ResetIdentity()
		return nil
	case binding.FieldVerified:
		m.ResetVerified()
		return nil
	case binding.FieldSalt:
		m.ResetSalt()
		return nil
	case binding.FieldUserID:
		m.ResetUserID()
		return nil
	case binding.FieldApplicationID:
		m.ResetApplicationID()
		return nil
	}
	return fmt.Errorf("unknown Binding field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *BindingMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.user != nil {
		edges = append(edges, binding.EdgeUser)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *BindingMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case binding.EdgeUser:
		if id := m.user; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *BindingMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *BindingMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *BindingMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.cleareduser {
		edges = append(edges, binding.EdgeUser)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *BindingMutation) EdgeCleared(name string) bool {
	switch name {
	case binding.EdgeUser:
		return m.cleareduser
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *BindingMutation) ClearEdge(name string) error {
	switch name {
	case binding.EdgeUser:
		m.ClearUser()
		return nil
	}
	return fmt.Errorf("unknown Binding unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *BindingMutation) ResetEdge(name string) error {
	switch name {
	case binding.EdgeUser:
		m.ResetUser()
		return nil
	}
	return fmt.Errorf("unknown Binding edge %s", name)
}

// BindingVerifyMutation represents an operation that mutates the BindingVerify nodes in the graph.
type BindingVerifyMutation struct {
	config
	op            Op
	typ           string
	id            *uuid.UUID
	created_at    *time.Time
	updated_at    *time.Time
	deleted_at    *time.Time
	user_id       *string
	_type         *bindingverify.Type
	identity      *string
	code          *string
	expires_at    *time.Time
	verified_at   *time.Time
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*BindingVerify, error)
	predicates    []predicate.BindingVerify
}

var _ ent.Mutation = (*BindingVerifyMutation)(nil)

// bindingverifyOption allows management of the mutation configuration using functional options.
type bindingverifyOption func(*BindingVerifyMutation)

// newBindingVerifyMutation creates new mutation for the BindingVerify entity.
func newBindingVerifyMutation(c config, op Op, opts ...bindingverifyOption) *BindingVerifyMutation {
	m := &BindingVerifyMutation{
		config:        c,
		op:            op,
		typ:           TypeBindingVerify,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withBindingVerifyID sets the ID field of the mutation.
func withBindingVerifyID(id uuid.UUID) bindingverifyOption {
	return func(m *BindingVerifyMutation) {
		var (
			err   error
			once  sync.Once
			value *BindingVerify
		)
		m.oldValue = func(ctx context.Context) (*BindingVerify, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().BindingVerify.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withBindingVerify sets the old BindingVerify of the mutation.
func withBindingVerify(node *BindingVerify) bindingverifyOption {
	return func(m *BindingVerifyMutation) {
		m.oldValue = func(context.Context) (*BindingVerify, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m BindingVerifyMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m BindingVerifyMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of BindingVerify entities.
func (m *BindingVerifyMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *BindingVerifyMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *BindingVerifyMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().BindingVerify.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *BindingVerifyMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *BindingVerifyMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the BindingVerify entity.
// If the BindingVerify object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BindingVerifyMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *BindingVerifyMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *BindingVerifyMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *BindingVerifyMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the BindingVerify entity.
// If the BindingVerify object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BindingVerifyMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *BindingVerifyMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *BindingVerifyMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *BindingVerifyMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the BindingVerify entity.
// If the BindingVerify object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BindingVerifyMutation) OldDeletedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *BindingVerifyMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[bindingverify.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *BindingVerifyMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[bindingverify.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *BindingVerifyMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, bindingverify.FieldDeletedAt)
}

// SetUserID sets the "user_id" field.
func (m *BindingVerifyMutation) SetUserID(s string) {
	m.user_id = &s
}

// UserID returns the value of the "user_id" field in the mutation.
func (m *BindingVerifyMutation) UserID() (r string, exists bool) {
	v := m.user_id
	if v == nil {
		return
	}
	return *v, true
}

// OldUserID returns the old "user_id" field's value of the BindingVerify entity.
// If the BindingVerify object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BindingVerifyMutation) OldUserID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserID: %w", err)
	}
	return oldValue.UserID, nil
}

// ResetUserID resets all changes to the "user_id" field.
func (m *BindingVerifyMutation) ResetUserID() {
	m.user_id = nil
}

// SetType sets the "type" field.
func (m *BindingVerifyMutation) SetType(b bindingverify.Type) {
	m._type = &b
}

// GetType returns the value of the "type" field in the mutation.
func (m *BindingVerifyMutation) GetType() (r bindingverify.Type, exists bool) {
	v := m._type
	if v == nil {
		return
	}
	return *v, true
}

// OldType returns the old "type" field's value of the BindingVerify entity.
// If the BindingVerify object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BindingVerifyMutation) OldType(ctx context.Context) (v bindingverify.Type, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldType: %w", err)
	}
	return oldValue.Type, nil
}

// ResetType resets all changes to the "type" field.
func (m *BindingVerifyMutation) ResetType() {
	m._type = nil
}

// SetIdentity sets the "identity" field.
func (m *BindingVerifyMutation) SetIdentity(s string) {
	m.identity = &s
}

// Identity returns the value of the "identity" field in the mutation.
func (m *BindingVerifyMutation) Identity() (r string, exists bool) {
	v := m.identity
	if v == nil {
		return
	}
	return *v, true
}

// OldIdentity returns the old "identity" field's value of the BindingVerify entity.
// If the BindingVerify object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BindingVerifyMutation) OldIdentity(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIdentity is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIdentity requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIdentity: %w", err)
	}
	return oldValue.Identity, nil
}

// ResetIdentity resets all changes to the "identity" field.
func (m *BindingVerifyMutation) ResetIdentity() {
	m.identity = nil
}

// SetCode sets the "code" field.
func (m *BindingVerifyMutation) SetCode(s string) {
	m.code = &s
}

// Code returns the value of the "code" field in the mutation.
func (m *BindingVerifyMutation) Code() (r string, exists bool) {
	v := m.code
	if v == nil {
		return
	}
	return *v, true
}

// OldCode returns the old "code" field's value of the BindingVerify entity.
// If the BindingVerify object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BindingVerifyMutation) OldCode(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCode: %w", err)
	}
	return oldValue.Code, nil
}

// ResetCode resets all changes to the "code" field.
func (m *BindingVerifyMutation) ResetCode() {
	m.code = nil
}

// SetExpiresAt sets the "expires_at" field.
func (m *BindingVerifyMutation) SetExpiresAt(t time.Time) {
	m.expires_at = &t
}

// ExpiresAt returns the value of the "expires_at" field in the mutation.
func (m *BindingVerifyMutation) ExpiresAt() (r time.Time, exists bool) {
	v := m.expires_at
	if v == nil {
		return
	}
	return *v, true
}

// OldExpiresAt returns the old "expires_at" field's value of the BindingVerify entity.
// If the BindingVerify object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BindingVerifyMutation) OldExpiresAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldExpiresAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldExpiresAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExpiresAt: %w", err)
	}
	return oldValue.ExpiresAt, nil
}

// ResetExpiresAt resets all changes to the "expires_at" field.
func (m *BindingVerifyMutation) ResetExpiresAt() {
	m.expires_at = nil
}

// SetVerifiedAt sets the "verified_at" field.
func (m *BindingVerifyMutation) SetVerifiedAt(t time.Time) {
	m.verified_at = &t
}

// VerifiedAt returns the value of the "verified_at" field in the mutation.
func (m *BindingVerifyMutation) VerifiedAt() (r time.Time, exists bool) {
	v := m.verified_at
	if v == nil {
		return
	}
	return *v, true
}

// OldVerifiedAt returns the old "verified_at" field's value of the BindingVerify entity.
// If the BindingVerify object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BindingVerifyMutation) OldVerifiedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldVerifiedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldVerifiedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldVerifiedAt: %w", err)
	}
	return oldValue.VerifiedAt, nil
}

// ResetVerifiedAt resets all changes to the "verified_at" field.
func (m *BindingVerifyMutation) ResetVerifiedAt() {
	m.verified_at = nil
}

// Where appends a list predicates to the BindingVerifyMutation builder.
func (m *BindingVerifyMutation) Where(ps ...predicate.BindingVerify) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the BindingVerifyMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *BindingVerifyMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.BindingVerify, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *BindingVerifyMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *BindingVerifyMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (BindingVerify).
func (m *BindingVerifyMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *BindingVerifyMutation) Fields() []string {
	fields := make([]string, 0, 9)
	if m.created_at != nil {
		fields = append(fields, bindingverify.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, bindingverify.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, bindingverify.FieldDeletedAt)
	}
	if m.user_id != nil {
		fields = append(fields, bindingverify.FieldUserID)
	}
	if m._type != nil {
		fields = append(fields, bindingverify.FieldType)
	}
	if m.identity != nil {
		fields = append(fields, bindingverify.FieldIdentity)
	}
	if m.code != nil {
		fields = append(fields, bindingverify.FieldCode)
	}
	if m.expires_at != nil {
		fields = append(fields, bindingverify.FieldExpiresAt)
	}
	if m.verified_at != nil {
		fields = append(fields, bindingverify.FieldVerifiedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *BindingVerifyMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case bindingverify.FieldCreatedAt:
		return m.CreatedAt()
	case bindingverify.FieldUpdatedAt:
		return m.UpdatedAt()
	case bindingverify.FieldDeletedAt:
		return m.DeletedAt()
	case bindingverify.FieldUserID:
		return m.UserID()
	case bindingverify.FieldType:
		return m.GetType()
	case bindingverify.FieldIdentity:
		return m.Identity()
	case bindingverify.FieldCode:
		return m.Code()
	case bindingverify.FieldExpiresAt:
		return m.ExpiresAt()
	case bindingverify.FieldVerifiedAt:
		return m.VerifiedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *BindingVerifyMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case bindingverify.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case bindingverify.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case bindingverify.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case bindingverify.FieldUserID:
		return m.OldUserID(ctx)
	case bindingverify.FieldType:
		return m.OldType(ctx)
	case bindingverify.FieldIdentity:
		return m.OldIdentity(ctx)
	case bindingverify.FieldCode:
		return m.OldCode(ctx)
	case bindingverify.FieldExpiresAt:
		return m.OldExpiresAt(ctx)
	case bindingverify.FieldVerifiedAt:
		return m.OldVerifiedAt(ctx)
	}
	return nil, fmt.Errorf("unknown BindingVerify field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *BindingVerifyMutation) SetField(name string, value ent.Value) error {
	switch name {
	case bindingverify.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case bindingverify.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case bindingverify.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case bindingverify.FieldUserID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserID(v)
		return nil
	case bindingverify.FieldType:
		v, ok := value.(bindingverify.Type)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetType(v)
		return nil
	case bindingverify.FieldIdentity:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIdentity(v)
		return nil
	case bindingverify.FieldCode:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCode(v)
		return nil
	case bindingverify.FieldExpiresAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExpiresAt(v)
		return nil
	case bindingverify.FieldVerifiedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetVerifiedAt(v)
		return nil
	}
	return fmt.Errorf("unknown BindingVerify field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *BindingVerifyMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *BindingVerifyMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *BindingVerifyMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown BindingVerify numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *BindingVerifyMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(bindingverify.FieldDeletedAt) {
		fields = append(fields, bindingverify.FieldDeletedAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *BindingVerifyMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *BindingVerifyMutation) ClearField(name string) error {
	switch name {
	case bindingverify.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	}
	return fmt.Errorf("unknown BindingVerify nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *BindingVerifyMutation) ResetField(name string) error {
	switch name {
	case bindingverify.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case bindingverify.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case bindingverify.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case bindingverify.FieldUserID:
		m.ResetUserID()
		return nil
	case bindingverify.FieldType:
		m.ResetType()
		return nil
	case bindingverify.FieldIdentity:
		m.ResetIdentity()
		return nil
	case bindingverify.FieldCode:
		m.ResetCode()
		return nil
	case bindingverify.FieldExpiresAt:
		m.ResetExpiresAt()
		return nil
	case bindingverify.FieldVerifiedAt:
		m.ResetVerifiedAt()
		return nil
	}
	return fmt.Errorf("unknown BindingVerify field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *BindingVerifyMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *BindingVerifyMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *BindingVerifyMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *BindingVerifyMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *BindingVerifyMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *BindingVerifyMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *BindingVerifyMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown BindingVerify unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *BindingVerifyMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown BindingVerify edge %s", name)
}

// DeviceMutation represents an operation that mutates the Device nodes in the graph.
type DeviceMutation struct {
	config
	op                       Op
	typ                      string
	id                       *int64
	created_at               *time.Time
	updated_at               *time.Time
	deleted_at               *time.Time
	organization_id          *uuid.UUID
	device_type              *string
	device_id                *string
	refresh_token            *string
	refresh_token_expires_at *time.Time
	clearedFields            map[string]struct{}
	user                     *string
	cleareduser              bool
	done                     bool
	oldValue                 func(context.Context) (*Device, error)
	predicates               []predicate.Device
}

var _ ent.Mutation = (*DeviceMutation)(nil)

// deviceOption allows management of the mutation configuration using functional options.
type deviceOption func(*DeviceMutation)

// newDeviceMutation creates new mutation for the Device entity.
func newDeviceMutation(c config, op Op, opts ...deviceOption) *DeviceMutation {
	m := &DeviceMutation{
		config:        c,
		op:            op,
		typ:           TypeDevice,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withDeviceID sets the ID field of the mutation.
func withDeviceID(id int64) deviceOption {
	return func(m *DeviceMutation) {
		var (
			err   error
			once  sync.Once
			value *Device
		)
		m.oldValue = func(ctx context.Context) (*Device, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Device.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withDevice sets the old Device of the mutation.
func withDevice(node *Device) deviceOption {
	return func(m *DeviceMutation) {
		m.oldValue = func(context.Context) (*Device, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m DeviceMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m DeviceMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Device entities.
func (m *DeviceMutation) SetID(id int64) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *DeviceMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *DeviceMutation) IDs(ctx context.Context) ([]int64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Device.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *DeviceMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *DeviceMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Device entity.
// If the Device object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DeviceMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *DeviceMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *DeviceMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *DeviceMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Device entity.
// If the Device object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DeviceMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *DeviceMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *DeviceMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *DeviceMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the Device entity.
// If the Device object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DeviceMutation) OldDeletedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *DeviceMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[device.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *DeviceMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[device.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *DeviceMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, device.FieldDeletedAt)
}

// SetUserID sets the "user_id" field.
func (m *DeviceMutation) SetUserID(s string) {
	m.user = &s
}

// UserID returns the value of the "user_id" field in the mutation.
func (m *DeviceMutation) UserID() (r string, exists bool) {
	v := m.user
	if v == nil {
		return
	}
	return *v, true
}

// OldUserID returns the old "user_id" field's value of the Device entity.
// If the Device object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DeviceMutation) OldUserID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserID: %w", err)
	}
	return oldValue.UserID, nil
}

// ResetUserID resets all changes to the "user_id" field.
func (m *DeviceMutation) ResetUserID() {
	m.user = nil
}

// SetOrganizationID sets the "organization_id" field.
func (m *DeviceMutation) SetOrganizationID(u uuid.UUID) {
	m.organization_id = &u
}

// OrganizationID returns the value of the "organization_id" field in the mutation.
func (m *DeviceMutation) OrganizationID() (r uuid.UUID, exists bool) {
	v := m.organization_id
	if v == nil {
		return
	}
	return *v, true
}

// OldOrganizationID returns the old "organization_id" field's value of the Device entity.
// If the Device object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DeviceMutation) OldOrganizationID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOrganizationID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOrganizationID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOrganizationID: %w", err)
	}
	return oldValue.OrganizationID, nil
}

// ClearOrganizationID clears the value of the "organization_id" field.
func (m *DeviceMutation) ClearOrganizationID() {
	m.organization_id = nil
	m.clearedFields[device.FieldOrganizationID] = struct{}{}
}

// OrganizationIDCleared returns if the "organization_id" field was cleared in this mutation.
func (m *DeviceMutation) OrganizationIDCleared() bool {
	_, ok := m.clearedFields[device.FieldOrganizationID]
	return ok
}

// ResetOrganizationID resets all changes to the "organization_id" field.
func (m *DeviceMutation) ResetOrganizationID() {
	m.organization_id = nil
	delete(m.clearedFields, device.FieldOrganizationID)
}

// SetDeviceType sets the "device_type" field.
func (m *DeviceMutation) SetDeviceType(s string) {
	m.device_type = &s
}

// DeviceType returns the value of the "device_type" field in the mutation.
func (m *DeviceMutation) DeviceType() (r string, exists bool) {
	v := m.device_type
	if v == nil {
		return
	}
	return *v, true
}

// OldDeviceType returns the old "device_type" field's value of the Device entity.
// If the Device object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DeviceMutation) OldDeviceType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeviceType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeviceType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeviceType: %w", err)
	}
	return oldValue.DeviceType, nil
}

// ResetDeviceType resets all changes to the "device_type" field.
func (m *DeviceMutation) ResetDeviceType() {
	m.device_type = nil
}

// SetDeviceID sets the "device_id" field.
func (m *DeviceMutation) SetDeviceID(s string) {
	m.device_id = &s
}

// DeviceID returns the value of the "device_id" field in the mutation.
func (m *DeviceMutation) DeviceID() (r string, exists bool) {
	v := m.device_id
	if v == nil {
		return
	}
	return *v, true
}

// OldDeviceID returns the old "device_id" field's value of the Device entity.
// If the Device object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DeviceMutation) OldDeviceID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeviceID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeviceID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeviceID: %w", err)
	}
	return oldValue.DeviceID, nil
}

// ResetDeviceID resets all changes to the "device_id" field.
func (m *DeviceMutation) ResetDeviceID() {
	m.device_id = nil
}

// SetRefreshToken sets the "refresh_token" field.
func (m *DeviceMutation) SetRefreshToken(s string) {
	m.refresh_token = &s
}

// RefreshToken returns the value of the "refresh_token" field in the mutation.
func (m *DeviceMutation) RefreshToken() (r string, exists bool) {
	v := m.refresh_token
	if v == nil {
		return
	}
	return *v, true
}

// OldRefreshToken returns the old "refresh_token" field's value of the Device entity.
// If the Device object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DeviceMutation) OldRefreshToken(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRefreshToken is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRefreshToken requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRefreshToken: %w", err)
	}
	return oldValue.RefreshToken, nil
}

// ResetRefreshToken resets all changes to the "refresh_token" field.
func (m *DeviceMutation) ResetRefreshToken() {
	m.refresh_token = nil
}

// SetRefreshTokenExpiresAt sets the "refresh_token_expires_at" field.
func (m *DeviceMutation) SetRefreshTokenExpiresAt(t time.Time) {
	m.refresh_token_expires_at = &t
}

// RefreshTokenExpiresAt returns the value of the "refresh_token_expires_at" field in the mutation.
func (m *DeviceMutation) RefreshTokenExpiresAt() (r time.Time, exists bool) {
	v := m.refresh_token_expires_at
	if v == nil {
		return
	}
	return *v, true
}

// OldRefreshTokenExpiresAt returns the old "refresh_token_expires_at" field's value of the Device entity.
// If the Device object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DeviceMutation) OldRefreshTokenExpiresAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRefreshTokenExpiresAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRefreshTokenExpiresAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRefreshTokenExpiresAt: %w", err)
	}
	return oldValue.RefreshTokenExpiresAt, nil
}

// ResetRefreshTokenExpiresAt resets all changes to the "refresh_token_expires_at" field.
func (m *DeviceMutation) ResetRefreshTokenExpiresAt() {
	m.refresh_token_expires_at = nil
}

// ClearUser clears the "user" edge to the User entity.
func (m *DeviceMutation) ClearUser() {
	m.cleareduser = true
	m.clearedFields[device.FieldUserID] = struct{}{}
}

// UserCleared reports if the "user" edge to the User entity was cleared.
func (m *DeviceMutation) UserCleared() bool {
	return m.cleareduser
}

// UserIDs returns the "user" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UserID instead. It exists only for internal usage by the builders.
func (m *DeviceMutation) UserIDs() (ids []string) {
	if id := m.user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUser resets all changes to the "user" edge.
func (m *DeviceMutation) ResetUser() {
	m.user = nil
	m.cleareduser = false
}

// Where appends a list predicates to the DeviceMutation builder.
func (m *DeviceMutation) Where(ps ...predicate.Device) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the DeviceMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *DeviceMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Device, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *DeviceMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *DeviceMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Device).
func (m *DeviceMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *DeviceMutation) Fields() []string {
	fields := make([]string, 0, 9)
	if m.created_at != nil {
		fields = append(fields, device.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, device.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, device.FieldDeletedAt)
	}
	if m.user != nil {
		fields = append(fields, device.FieldUserID)
	}
	if m.organization_id != nil {
		fields = append(fields, device.FieldOrganizationID)
	}
	if m.device_type != nil {
		fields = append(fields, device.FieldDeviceType)
	}
	if m.device_id != nil {
		fields = append(fields, device.FieldDeviceID)
	}
	if m.refresh_token != nil {
		fields = append(fields, device.FieldRefreshToken)
	}
	if m.refresh_token_expires_at != nil {
		fields = append(fields, device.FieldRefreshTokenExpiresAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *DeviceMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case device.FieldCreatedAt:
		return m.CreatedAt()
	case device.FieldUpdatedAt:
		return m.UpdatedAt()
	case device.FieldDeletedAt:
		return m.DeletedAt()
	case device.FieldUserID:
		return m.UserID()
	case device.FieldOrganizationID:
		return m.OrganizationID()
	case device.FieldDeviceType:
		return m.DeviceType()
	case device.FieldDeviceID:
		return m.DeviceID()
	case device.FieldRefreshToken:
		return m.RefreshToken()
	case device.FieldRefreshTokenExpiresAt:
		return m.RefreshTokenExpiresAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *DeviceMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case device.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case device.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case device.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case device.FieldUserID:
		return m.OldUserID(ctx)
	case device.FieldOrganizationID:
		return m.OldOrganizationID(ctx)
	case device.FieldDeviceType:
		return m.OldDeviceType(ctx)
	case device.FieldDeviceID:
		return m.OldDeviceID(ctx)
	case device.FieldRefreshToken:
		return m.OldRefreshToken(ctx)
	case device.FieldRefreshTokenExpiresAt:
		return m.OldRefreshTokenExpiresAt(ctx)
	}
	return nil, fmt.Errorf("unknown Device field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *DeviceMutation) SetField(name string, value ent.Value) error {
	switch name {
	case device.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case device.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case device.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case device.FieldUserID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserID(v)
		return nil
	case device.FieldOrganizationID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOrganizationID(v)
		return nil
	case device.FieldDeviceType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeviceType(v)
		return nil
	case device.FieldDeviceID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeviceID(v)
		return nil
	case device.FieldRefreshToken:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRefreshToken(v)
		return nil
	case device.FieldRefreshTokenExpiresAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRefreshTokenExpiresAt(v)
		return nil
	}
	return fmt.Errorf("unknown Device field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *DeviceMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *DeviceMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *DeviceMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Device numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *DeviceMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(device.FieldDeletedAt) {
		fields = append(fields, device.FieldDeletedAt)
	}
	if m.FieldCleared(device.FieldOrganizationID) {
		fields = append(fields, device.FieldOrganizationID)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *DeviceMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *DeviceMutation) ClearField(name string) error {
	switch name {
	case device.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case device.FieldOrganizationID:
		m.ClearOrganizationID()
		return nil
	}
	return fmt.Errorf("unknown Device nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *DeviceMutation) ResetField(name string) error {
	switch name {
	case device.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case device.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case device.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case device.FieldUserID:
		m.ResetUserID()
		return nil
	case device.FieldOrganizationID:
		m.ResetOrganizationID()
		return nil
	case device.FieldDeviceType:
		m.ResetDeviceType()
		return nil
	case device.FieldDeviceID:
		m.ResetDeviceID()
		return nil
	case device.FieldRefreshToken:
		m.ResetRefreshToken()
		return nil
	case device.FieldRefreshTokenExpiresAt:
		m.ResetRefreshTokenExpiresAt()
		return nil
	}
	return fmt.Errorf("unknown Device field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *DeviceMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.user != nil {
		edges = append(edges, device.EdgeUser)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *DeviceMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case device.EdgeUser:
		if id := m.user; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *DeviceMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *DeviceMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *DeviceMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.cleareduser {
		edges = append(edges, device.EdgeUser)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *DeviceMutation) EdgeCleared(name string) bool {
	switch name {
	case device.EdgeUser:
		return m.cleareduser
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *DeviceMutation) ClearEdge(name string) error {
	switch name {
	case device.EdgeUser:
		m.ClearUser()
		return nil
	}
	return fmt.Errorf("unknown Device unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *DeviceMutation) ResetEdge(name string) error {
	switch name {
	case device.EdgeUser:
		m.ResetUser()
		return nil
	}
	return fmt.Errorf("unknown Device edge %s", name)
}

// MailVertifyCodeMutation represents an operation that mutates the MailVertifyCode nodes in the graph.
type MailVertifyCodeMutation struct {
	config
	op            Op
	typ           string
	id            *uuid.UUID
	created_at    *time.Time
	updated_at    *time.Time
	deleted_at    *time.Time
	_type         *mailvertifycode.Type
	email         *string
	code          *string
	expires_at    *time.Time
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*MailVertifyCode, error)
	predicates    []predicate.MailVertifyCode
}

var _ ent.Mutation = (*MailVertifyCodeMutation)(nil)

// mailvertifycodeOption allows management of the mutation configuration using functional options.
type mailvertifycodeOption func(*MailVertifyCodeMutation)

// newMailVertifyCodeMutation creates new mutation for the MailVertifyCode entity.
func newMailVertifyCodeMutation(c config, op Op, opts ...mailvertifycodeOption) *MailVertifyCodeMutation {
	m := &MailVertifyCodeMutation{
		config:        c,
		op:            op,
		typ:           TypeMailVertifyCode,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withMailVertifyCodeID sets the ID field of the mutation.
func withMailVertifyCodeID(id uuid.UUID) mailvertifycodeOption {
	return func(m *MailVertifyCodeMutation) {
		var (
			err   error
			once  sync.Once
			value *MailVertifyCode
		)
		m.oldValue = func(ctx context.Context) (*MailVertifyCode, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().MailVertifyCode.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withMailVertifyCode sets the old MailVertifyCode of the mutation.
func withMailVertifyCode(node *MailVertifyCode) mailvertifycodeOption {
	return func(m *MailVertifyCodeMutation) {
		m.oldValue = func(context.Context) (*MailVertifyCode, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m MailVertifyCodeMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m MailVertifyCodeMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of MailVertifyCode entities.
func (m *MailVertifyCodeMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *MailVertifyCodeMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *MailVertifyCodeMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().MailVertifyCode.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *MailVertifyCodeMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *MailVertifyCodeMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the MailVertifyCode entity.
// If the MailVertifyCode object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MailVertifyCodeMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *MailVertifyCodeMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *MailVertifyCodeMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *MailVertifyCodeMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the MailVertifyCode entity.
// If the MailVertifyCode object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MailVertifyCodeMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *MailVertifyCodeMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *MailVertifyCodeMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *MailVertifyCodeMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the MailVertifyCode entity.
// If the MailVertifyCode object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MailVertifyCodeMutation) OldDeletedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *MailVertifyCodeMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[mailvertifycode.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *MailVertifyCodeMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[mailvertifycode.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *MailVertifyCodeMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, mailvertifycode.FieldDeletedAt)
}

// SetType sets the "type" field.
func (m *MailVertifyCodeMutation) SetType(value mailvertifycode.Type) {
	m._type = &value
}

// GetType returns the value of the "type" field in the mutation.
func (m *MailVertifyCodeMutation) GetType() (r mailvertifycode.Type, exists bool) {
	v := m._type
	if v == nil {
		return
	}
	return *v, true
}

// OldType returns the old "type" field's value of the MailVertifyCode entity.
// If the MailVertifyCode object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MailVertifyCodeMutation) OldType(ctx context.Context) (v mailvertifycode.Type, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldType: %w", err)
	}
	return oldValue.Type, nil
}

// ResetType resets all changes to the "type" field.
func (m *MailVertifyCodeMutation) ResetType() {
	m._type = nil
}

// SetEmail sets the "email" field.
func (m *MailVertifyCodeMutation) SetEmail(s string) {
	m.email = &s
}

// Email returns the value of the "email" field in the mutation.
func (m *MailVertifyCodeMutation) Email() (r string, exists bool) {
	v := m.email
	if v == nil {
		return
	}
	return *v, true
}

// OldEmail returns the old "email" field's value of the MailVertifyCode entity.
// If the MailVertifyCode object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MailVertifyCodeMutation) OldEmail(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEmail is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEmail requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEmail: %w", err)
	}
	return oldValue.Email, nil
}

// ResetEmail resets all changes to the "email" field.
func (m *MailVertifyCodeMutation) ResetEmail() {
	m.email = nil
}

// SetCode sets the "code" field.
func (m *MailVertifyCodeMutation) SetCode(s string) {
	m.code = &s
}

// Code returns the value of the "code" field in the mutation.
func (m *MailVertifyCodeMutation) Code() (r string, exists bool) {
	v := m.code
	if v == nil {
		return
	}
	return *v, true
}

// OldCode returns the old "code" field's value of the MailVertifyCode entity.
// If the MailVertifyCode object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MailVertifyCodeMutation) OldCode(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCode: %w", err)
	}
	return oldValue.Code, nil
}

// ResetCode resets all changes to the "code" field.
func (m *MailVertifyCodeMutation) ResetCode() {
	m.code = nil
}

// SetExpiresAt sets the "expires_at" field.
func (m *MailVertifyCodeMutation) SetExpiresAt(t time.Time) {
	m.expires_at = &t
}

// ExpiresAt returns the value of the "expires_at" field in the mutation.
func (m *MailVertifyCodeMutation) ExpiresAt() (r time.Time, exists bool) {
	v := m.expires_at
	if v == nil {
		return
	}
	return *v, true
}

// OldExpiresAt returns the old "expires_at" field's value of the MailVertifyCode entity.
// If the MailVertifyCode object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MailVertifyCodeMutation) OldExpiresAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldExpiresAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldExpiresAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExpiresAt: %w", err)
	}
	return oldValue.ExpiresAt, nil
}

// ResetExpiresAt resets all changes to the "expires_at" field.
func (m *MailVertifyCodeMutation) ResetExpiresAt() {
	m.expires_at = nil
}

// Where appends a list predicates to the MailVertifyCodeMutation builder.
func (m *MailVertifyCodeMutation) Where(ps ...predicate.MailVertifyCode) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the MailVertifyCodeMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *MailVertifyCodeMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.MailVertifyCode, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *MailVertifyCodeMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *MailVertifyCodeMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (MailVertifyCode).
func (m *MailVertifyCodeMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *MailVertifyCodeMutation) Fields() []string {
	fields := make([]string, 0, 7)
	if m.created_at != nil {
		fields = append(fields, mailvertifycode.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, mailvertifycode.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, mailvertifycode.FieldDeletedAt)
	}
	if m._type != nil {
		fields = append(fields, mailvertifycode.FieldType)
	}
	if m.email != nil {
		fields = append(fields, mailvertifycode.FieldEmail)
	}
	if m.code != nil {
		fields = append(fields, mailvertifycode.FieldCode)
	}
	if m.expires_at != nil {
		fields = append(fields, mailvertifycode.FieldExpiresAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *MailVertifyCodeMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case mailvertifycode.FieldCreatedAt:
		return m.CreatedAt()
	case mailvertifycode.FieldUpdatedAt:
		return m.UpdatedAt()
	case mailvertifycode.FieldDeletedAt:
		return m.DeletedAt()
	case mailvertifycode.FieldType:
		return m.GetType()
	case mailvertifycode.FieldEmail:
		return m.Email()
	case mailvertifycode.FieldCode:
		return m.Code()
	case mailvertifycode.FieldExpiresAt:
		return m.ExpiresAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *MailVertifyCodeMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case mailvertifycode.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case mailvertifycode.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case mailvertifycode.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case mailvertifycode.FieldType:
		return m.OldType(ctx)
	case mailvertifycode.FieldEmail:
		return m.OldEmail(ctx)
	case mailvertifycode.FieldCode:
		return m.OldCode(ctx)
	case mailvertifycode.FieldExpiresAt:
		return m.OldExpiresAt(ctx)
	}
	return nil, fmt.Errorf("unknown MailVertifyCode field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *MailVertifyCodeMutation) SetField(name string, value ent.Value) error {
	switch name {
	case mailvertifycode.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case mailvertifycode.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case mailvertifycode.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case mailvertifycode.FieldType:
		v, ok := value.(mailvertifycode.Type)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetType(v)
		return nil
	case mailvertifycode.FieldEmail:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEmail(v)
		return nil
	case mailvertifycode.FieldCode:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCode(v)
		return nil
	case mailvertifycode.FieldExpiresAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExpiresAt(v)
		return nil
	}
	return fmt.Errorf("unknown MailVertifyCode field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *MailVertifyCodeMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *MailVertifyCodeMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *MailVertifyCodeMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown MailVertifyCode numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *MailVertifyCodeMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(mailvertifycode.FieldDeletedAt) {
		fields = append(fields, mailvertifycode.FieldDeletedAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *MailVertifyCodeMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *MailVertifyCodeMutation) ClearField(name string) error {
	switch name {
	case mailvertifycode.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	}
	return fmt.Errorf("unknown MailVertifyCode nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *MailVertifyCodeMutation) ResetField(name string) error {
	switch name {
	case mailvertifycode.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case mailvertifycode.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case mailvertifycode.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case mailvertifycode.FieldType:
		m.ResetType()
		return nil
	case mailvertifycode.FieldEmail:
		m.ResetEmail()
		return nil
	case mailvertifycode.FieldCode:
		m.ResetCode()
		return nil
	case mailvertifycode.FieldExpiresAt:
		m.ResetExpiresAt()
		return nil
	}
	return fmt.Errorf("unknown MailVertifyCode field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *MailVertifyCodeMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *MailVertifyCodeMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *MailVertifyCodeMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *MailVertifyCodeMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *MailVertifyCodeMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *MailVertifyCodeMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *MailVertifyCodeMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown MailVertifyCode unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *MailVertifyCodeMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown MailVertifyCode edge %s", name)
}

// OrganizationMutation represents an operation that mutates the Organization nodes in the graph.
type OrganizationMutation struct {
	config
	op                 Op
	typ                string
	id                 *uuid.UUID
	created_at         *time.Time
	updated_at         *time.Time
	deleted_at         *time.Time
	name               *string
	status             *organization.Status
	refresh_at         *time.Time
	expires_at         *time.Time
	permission_code    *string
	logo_url           *string
	clearedFields      map[string]struct{}
	application        *uuid.UUID
	clearedapplication bool
	done               bool
	oldValue           func(context.Context) (*Organization, error)
	predicates         []predicate.Organization
}

var _ ent.Mutation = (*OrganizationMutation)(nil)

// organizationOption allows management of the mutation configuration using functional options.
type organizationOption func(*OrganizationMutation)

// newOrganizationMutation creates new mutation for the Organization entity.
func newOrganizationMutation(c config, op Op, opts ...organizationOption) *OrganizationMutation {
	m := &OrganizationMutation{
		config:        c,
		op:            op,
		typ:           TypeOrganization,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withOrganizationID sets the ID field of the mutation.
func withOrganizationID(id uuid.UUID) organizationOption {
	return func(m *OrganizationMutation) {
		var (
			err   error
			once  sync.Once
			value *Organization
		)
		m.oldValue = func(ctx context.Context) (*Organization, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Organization.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withOrganization sets the old Organization of the mutation.
func withOrganization(node *Organization) organizationOption {
	return func(m *OrganizationMutation) {
		m.oldValue = func(context.Context) (*Organization, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m OrganizationMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m OrganizationMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Organization entities.
func (m *OrganizationMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *OrganizationMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *OrganizationMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Organization.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *OrganizationMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *OrganizationMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Organization entity.
// If the Organization object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrganizationMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *OrganizationMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *OrganizationMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *OrganizationMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Organization entity.
// If the Organization object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrganizationMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *OrganizationMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *OrganizationMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *OrganizationMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the Organization entity.
// If the Organization object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrganizationMutation) OldDeletedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *OrganizationMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[organization.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *OrganizationMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[organization.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *OrganizationMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, organization.FieldDeletedAt)
}

// SetApplicationID sets the "application_id" field.
func (m *OrganizationMutation) SetApplicationID(u uuid.UUID) {
	m.application = &u
}

// ApplicationID returns the value of the "application_id" field in the mutation.
func (m *OrganizationMutation) ApplicationID() (r uuid.UUID, exists bool) {
	v := m.application
	if v == nil {
		return
	}
	return *v, true
}

// OldApplicationID returns the old "application_id" field's value of the Organization entity.
// If the Organization object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrganizationMutation) OldApplicationID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldApplicationID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldApplicationID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldApplicationID: %w", err)
	}
	return oldValue.ApplicationID, nil
}

// ResetApplicationID resets all changes to the "application_id" field.
func (m *OrganizationMutation) ResetApplicationID() {
	m.application = nil
}

// SetName sets the "name" field.
func (m *OrganizationMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *OrganizationMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Organization entity.
// If the Organization object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrganizationMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *OrganizationMutation) ResetName() {
	m.name = nil
}

// SetStatus sets the "status" field.
func (m *OrganizationMutation) SetStatus(o organization.Status) {
	m.status = &o
}

// Status returns the value of the "status" field in the mutation.
func (m *OrganizationMutation) Status() (r organization.Status, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the Organization entity.
// If the Organization object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrganizationMutation) OldStatus(ctx context.Context) (v organization.Status, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *OrganizationMutation) ResetStatus() {
	m.status = nil
}

// SetRefreshAt sets the "refresh_at" field.
func (m *OrganizationMutation) SetRefreshAt(t time.Time) {
	m.refresh_at = &t
}

// RefreshAt returns the value of the "refresh_at" field in the mutation.
func (m *OrganizationMutation) RefreshAt() (r time.Time, exists bool) {
	v := m.refresh_at
	if v == nil {
		return
	}
	return *v, true
}

// OldRefreshAt returns the old "refresh_at" field's value of the Organization entity.
// If the Organization object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrganizationMutation) OldRefreshAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRefreshAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRefreshAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRefreshAt: %w", err)
	}
	return oldValue.RefreshAt, nil
}

// ClearRefreshAt clears the value of the "refresh_at" field.
func (m *OrganizationMutation) ClearRefreshAt() {
	m.refresh_at = nil
	m.clearedFields[organization.FieldRefreshAt] = struct{}{}
}

// RefreshAtCleared returns if the "refresh_at" field was cleared in this mutation.
func (m *OrganizationMutation) RefreshAtCleared() bool {
	_, ok := m.clearedFields[organization.FieldRefreshAt]
	return ok
}

// ResetRefreshAt resets all changes to the "refresh_at" field.
func (m *OrganizationMutation) ResetRefreshAt() {
	m.refresh_at = nil
	delete(m.clearedFields, organization.FieldRefreshAt)
}

// SetExpiresAt sets the "expires_at" field.
func (m *OrganizationMutation) SetExpiresAt(t time.Time) {
	m.expires_at = &t
}

// ExpiresAt returns the value of the "expires_at" field in the mutation.
func (m *OrganizationMutation) ExpiresAt() (r time.Time, exists bool) {
	v := m.expires_at
	if v == nil {
		return
	}
	return *v, true
}

// OldExpiresAt returns the old "expires_at" field's value of the Organization entity.
// If the Organization object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrganizationMutation) OldExpiresAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldExpiresAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldExpiresAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExpiresAt: %w", err)
	}
	return oldValue.ExpiresAt, nil
}

// ClearExpiresAt clears the value of the "expires_at" field.
func (m *OrganizationMutation) ClearExpiresAt() {
	m.expires_at = nil
	m.clearedFields[organization.FieldExpiresAt] = struct{}{}
}

// ExpiresAtCleared returns if the "expires_at" field was cleared in this mutation.
func (m *OrganizationMutation) ExpiresAtCleared() bool {
	_, ok := m.clearedFields[organization.FieldExpiresAt]
	return ok
}

// ResetExpiresAt resets all changes to the "expires_at" field.
func (m *OrganizationMutation) ResetExpiresAt() {
	m.expires_at = nil
	delete(m.clearedFields, organization.FieldExpiresAt)
}

// SetPermissionCode sets the "permission_code" field.
func (m *OrganizationMutation) SetPermissionCode(s string) {
	m.permission_code = &s
}

// PermissionCode returns the value of the "permission_code" field in the mutation.
func (m *OrganizationMutation) PermissionCode() (r string, exists bool) {
	v := m.permission_code
	if v == nil {
		return
	}
	return *v, true
}

// OldPermissionCode returns the old "permission_code" field's value of the Organization entity.
// If the Organization object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrganizationMutation) OldPermissionCode(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPermissionCode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPermissionCode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPermissionCode: %w", err)
	}
	return oldValue.PermissionCode, nil
}

// ResetPermissionCode resets all changes to the "permission_code" field.
func (m *OrganizationMutation) ResetPermissionCode() {
	m.permission_code = nil
}

// SetLogoURL sets the "logo_url" field.
func (m *OrganizationMutation) SetLogoURL(s string) {
	m.logo_url = &s
}

// LogoURL returns the value of the "logo_url" field in the mutation.
func (m *OrganizationMutation) LogoURL() (r string, exists bool) {
	v := m.logo_url
	if v == nil {
		return
	}
	return *v, true
}

// OldLogoURL returns the old "logo_url" field's value of the Organization entity.
// If the Organization object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrganizationMutation) OldLogoURL(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLogoURL is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLogoURL requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLogoURL: %w", err)
	}
	return oldValue.LogoURL, nil
}

// ResetLogoURL resets all changes to the "logo_url" field.
func (m *OrganizationMutation) ResetLogoURL() {
	m.logo_url = nil
}

// ClearApplication clears the "application" edge to the Application entity.
func (m *OrganizationMutation) ClearApplication() {
	m.clearedapplication = true
	m.clearedFields[organization.FieldApplicationID] = struct{}{}
}

// ApplicationCleared reports if the "application" edge to the Application entity was cleared.
func (m *OrganizationMutation) ApplicationCleared() bool {
	return m.clearedapplication
}

// ApplicationIDs returns the "application" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ApplicationID instead. It exists only for internal usage by the builders.
func (m *OrganizationMutation) ApplicationIDs() (ids []uuid.UUID) {
	if id := m.application; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetApplication resets all changes to the "application" edge.
func (m *OrganizationMutation) ResetApplication() {
	m.application = nil
	m.clearedapplication = false
}

// Where appends a list predicates to the OrganizationMutation builder.
func (m *OrganizationMutation) Where(ps ...predicate.Organization) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the OrganizationMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *OrganizationMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Organization, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *OrganizationMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *OrganizationMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Organization).
func (m *OrganizationMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *OrganizationMutation) Fields() []string {
	fields := make([]string, 0, 10)
	if m.created_at != nil {
		fields = append(fields, organization.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, organization.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, organization.FieldDeletedAt)
	}
	if m.application != nil {
		fields = append(fields, organization.FieldApplicationID)
	}
	if m.name != nil {
		fields = append(fields, organization.FieldName)
	}
	if m.status != nil {
		fields = append(fields, organization.FieldStatus)
	}
	if m.refresh_at != nil {
		fields = append(fields, organization.FieldRefreshAt)
	}
	if m.expires_at != nil {
		fields = append(fields, organization.FieldExpiresAt)
	}
	if m.permission_code != nil {
		fields = append(fields, organization.FieldPermissionCode)
	}
	if m.logo_url != nil {
		fields = append(fields, organization.FieldLogoURL)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *OrganizationMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case organization.FieldCreatedAt:
		return m.CreatedAt()
	case organization.FieldUpdatedAt:
		return m.UpdatedAt()
	case organization.FieldDeletedAt:
		return m.DeletedAt()
	case organization.FieldApplicationID:
		return m.ApplicationID()
	case organization.FieldName:
		return m.Name()
	case organization.FieldStatus:
		return m.Status()
	case organization.FieldRefreshAt:
		return m.RefreshAt()
	case organization.FieldExpiresAt:
		return m.ExpiresAt()
	case organization.FieldPermissionCode:
		return m.PermissionCode()
	case organization.FieldLogoURL:
		return m.LogoURL()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *OrganizationMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case organization.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case organization.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case organization.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case organization.FieldApplicationID:
		return m.OldApplicationID(ctx)
	case organization.FieldName:
		return m.OldName(ctx)
	case organization.FieldStatus:
		return m.OldStatus(ctx)
	case organization.FieldRefreshAt:
		return m.OldRefreshAt(ctx)
	case organization.FieldExpiresAt:
		return m.OldExpiresAt(ctx)
	case organization.FieldPermissionCode:
		return m.OldPermissionCode(ctx)
	case organization.FieldLogoURL:
		return m.OldLogoURL(ctx)
	}
	return nil, fmt.Errorf("unknown Organization field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *OrganizationMutation) SetField(name string, value ent.Value) error {
	switch name {
	case organization.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case organization.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case organization.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case organization.FieldApplicationID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetApplicationID(v)
		return nil
	case organization.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case organization.FieldStatus:
		v, ok := value.(organization.Status)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case organization.FieldRefreshAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRefreshAt(v)
		return nil
	case organization.FieldExpiresAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExpiresAt(v)
		return nil
	case organization.FieldPermissionCode:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPermissionCode(v)
		return nil
	case organization.FieldLogoURL:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLogoURL(v)
		return nil
	}
	return fmt.Errorf("unknown Organization field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *OrganizationMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *OrganizationMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *OrganizationMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Organization numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *OrganizationMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(organization.FieldDeletedAt) {
		fields = append(fields, organization.FieldDeletedAt)
	}
	if m.FieldCleared(organization.FieldRefreshAt) {
		fields = append(fields, organization.FieldRefreshAt)
	}
	if m.FieldCleared(organization.FieldExpiresAt) {
		fields = append(fields, organization.FieldExpiresAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *OrganizationMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *OrganizationMutation) ClearField(name string) error {
	switch name {
	case organization.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case organization.FieldRefreshAt:
		m.ClearRefreshAt()
		return nil
	case organization.FieldExpiresAt:
		m.ClearExpiresAt()
		return nil
	}
	return fmt.Errorf("unknown Organization nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *OrganizationMutation) ResetField(name string) error {
	switch name {
	case organization.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case organization.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case organization.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case organization.FieldApplicationID:
		m.ResetApplicationID()
		return nil
	case organization.FieldName:
		m.ResetName()
		return nil
	case organization.FieldStatus:
		m.ResetStatus()
		return nil
	case organization.FieldRefreshAt:
		m.ResetRefreshAt()
		return nil
	case organization.FieldExpiresAt:
		m.ResetExpiresAt()
		return nil
	case organization.FieldPermissionCode:
		m.ResetPermissionCode()
		return nil
	case organization.FieldLogoURL:
		m.ResetLogoURL()
		return nil
	}
	return fmt.Errorf("unknown Organization field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *OrganizationMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.application != nil {
		edges = append(edges, organization.EdgeApplication)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *OrganizationMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case organization.EdgeApplication:
		if id := m.application; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *OrganizationMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *OrganizationMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *OrganizationMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedapplication {
		edges = append(edges, organization.EdgeApplication)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *OrganizationMutation) EdgeCleared(name string) bool {
	switch name {
	case organization.EdgeApplication:
		return m.clearedapplication
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *OrganizationMutation) ClearEdge(name string) error {
	switch name {
	case organization.EdgeApplication:
		m.ClearApplication()
		return nil
	}
	return fmt.Errorf("unknown Organization unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *OrganizationMutation) ResetEdge(name string) error {
	switch name {
	case organization.EdgeApplication:
		m.ResetApplication()
		return nil
	}
	return fmt.Errorf("unknown Organization edge %s", name)
}

// OrganizationApplicationMutation represents an operation that mutates the OrganizationApplication nodes in the graph.
type OrganizationApplicationMutation struct {
	config
	op                 Op
	typ                string
	id                 *uuid.UUID
	created_at         *time.Time
	updated_at         *time.Time
	deleted_at         *time.Time
	name               *string
	status             *organizationapplication.Status
	trial_days         *int32
	addtrial_days      *int32
	review_status      *organizationapplication.ReviewStatus
	review_comment     *string
	user_id            *string
	brand_short_name   *string
	primary_business   *string
	usage_scenario     *string
	referrer_name      *string
	discovery_way      *string
	org_role_name      *string
	clearedFields      map[string]struct{}
	application        *uuid.UUID
	clearedapplication bool
	done               bool
	oldValue           func(context.Context) (*OrganizationApplication, error)
	predicates         []predicate.OrganizationApplication
}

var _ ent.Mutation = (*OrganizationApplicationMutation)(nil)

// organizationapplicationOption allows management of the mutation configuration using functional options.
type organizationapplicationOption func(*OrganizationApplicationMutation)

// newOrganizationApplicationMutation creates new mutation for the OrganizationApplication entity.
func newOrganizationApplicationMutation(c config, op Op, opts ...organizationapplicationOption) *OrganizationApplicationMutation {
	m := &OrganizationApplicationMutation{
		config:        c,
		op:            op,
		typ:           TypeOrganizationApplication,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withOrganizationApplicationID sets the ID field of the mutation.
func withOrganizationApplicationID(id uuid.UUID) organizationapplicationOption {
	return func(m *OrganizationApplicationMutation) {
		var (
			err   error
			once  sync.Once
			value *OrganizationApplication
		)
		m.oldValue = func(ctx context.Context) (*OrganizationApplication, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().OrganizationApplication.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withOrganizationApplication sets the old OrganizationApplication of the mutation.
func withOrganizationApplication(node *OrganizationApplication) organizationapplicationOption {
	return func(m *OrganizationApplicationMutation) {
		m.oldValue = func(context.Context) (*OrganizationApplication, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m OrganizationApplicationMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m OrganizationApplicationMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of OrganizationApplication entities.
func (m *OrganizationApplicationMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *OrganizationApplicationMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *OrganizationApplicationMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().OrganizationApplication.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *OrganizationApplicationMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *OrganizationApplicationMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the OrganizationApplication entity.
// If the OrganizationApplication object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrganizationApplicationMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *OrganizationApplicationMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *OrganizationApplicationMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *OrganizationApplicationMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the OrganizationApplication entity.
// If the OrganizationApplication object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrganizationApplicationMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *OrganizationApplicationMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *OrganizationApplicationMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *OrganizationApplicationMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the OrganizationApplication entity.
// If the OrganizationApplication object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrganizationApplicationMutation) OldDeletedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *OrganizationApplicationMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[organizationapplication.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *OrganizationApplicationMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[organizationapplication.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *OrganizationApplicationMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, organizationapplication.FieldDeletedAt)
}

// SetApplicationID sets the "application_id" field.
func (m *OrganizationApplicationMutation) SetApplicationID(u uuid.UUID) {
	m.application = &u
}

// ApplicationID returns the value of the "application_id" field in the mutation.
func (m *OrganizationApplicationMutation) ApplicationID() (r uuid.UUID, exists bool) {
	v := m.application
	if v == nil {
		return
	}
	return *v, true
}

// OldApplicationID returns the old "application_id" field's value of the OrganizationApplication entity.
// If the OrganizationApplication object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrganizationApplicationMutation) OldApplicationID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldApplicationID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldApplicationID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldApplicationID: %w", err)
	}
	return oldValue.ApplicationID, nil
}

// ResetApplicationID resets all changes to the "application_id" field.
func (m *OrganizationApplicationMutation) ResetApplicationID() {
	m.application = nil
}

// SetName sets the "name" field.
func (m *OrganizationApplicationMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *OrganizationApplicationMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the OrganizationApplication entity.
// If the OrganizationApplication object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrganizationApplicationMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *OrganizationApplicationMutation) ResetName() {
	m.name = nil
}

// SetStatus sets the "status" field.
func (m *OrganizationApplicationMutation) SetStatus(o organizationapplication.Status) {
	m.status = &o
}

// Status returns the value of the "status" field in the mutation.
func (m *OrganizationApplicationMutation) Status() (r organizationapplication.Status, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the OrganizationApplication entity.
// If the OrganizationApplication object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrganizationApplicationMutation) OldStatus(ctx context.Context) (v organizationapplication.Status, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *OrganizationApplicationMutation) ResetStatus() {
	m.status = nil
}

// SetTrialDays sets the "trial_days" field.
func (m *OrganizationApplicationMutation) SetTrialDays(i int32) {
	m.trial_days = &i
	m.addtrial_days = nil
}

// TrialDays returns the value of the "trial_days" field in the mutation.
func (m *OrganizationApplicationMutation) TrialDays() (r int32, exists bool) {
	v := m.trial_days
	if v == nil {
		return
	}
	return *v, true
}

// OldTrialDays returns the old "trial_days" field's value of the OrganizationApplication entity.
// If the OrganizationApplication object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrganizationApplicationMutation) OldTrialDays(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTrialDays is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTrialDays requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTrialDays: %w", err)
	}
	return oldValue.TrialDays, nil
}

// AddTrialDays adds i to the "trial_days" field.
func (m *OrganizationApplicationMutation) AddTrialDays(i int32) {
	if m.addtrial_days != nil {
		*m.addtrial_days += i
	} else {
		m.addtrial_days = &i
	}
}

// AddedTrialDays returns the value that was added to the "trial_days" field in this mutation.
func (m *OrganizationApplicationMutation) AddedTrialDays() (r int32, exists bool) {
	v := m.addtrial_days
	if v == nil {
		return
	}
	return *v, true
}

// ClearTrialDays clears the value of the "trial_days" field.
func (m *OrganizationApplicationMutation) ClearTrialDays() {
	m.trial_days = nil
	m.addtrial_days = nil
	m.clearedFields[organizationapplication.FieldTrialDays] = struct{}{}
}

// TrialDaysCleared returns if the "trial_days" field was cleared in this mutation.
func (m *OrganizationApplicationMutation) TrialDaysCleared() bool {
	_, ok := m.clearedFields[organizationapplication.FieldTrialDays]
	return ok
}

// ResetTrialDays resets all changes to the "trial_days" field.
func (m *OrganizationApplicationMutation) ResetTrialDays() {
	m.trial_days = nil
	m.addtrial_days = nil
	delete(m.clearedFields, organizationapplication.FieldTrialDays)
}

// SetReviewStatus sets the "review_status" field.
func (m *OrganizationApplicationMutation) SetReviewStatus(os organizationapplication.ReviewStatus) {
	m.review_status = &os
}

// ReviewStatus returns the value of the "review_status" field in the mutation.
func (m *OrganizationApplicationMutation) ReviewStatus() (r organizationapplication.ReviewStatus, exists bool) {
	v := m.review_status
	if v == nil {
		return
	}
	return *v, true
}

// OldReviewStatus returns the old "review_status" field's value of the OrganizationApplication entity.
// If the OrganizationApplication object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrganizationApplicationMutation) OldReviewStatus(ctx context.Context) (v organizationapplication.ReviewStatus, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldReviewStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldReviewStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldReviewStatus: %w", err)
	}
	return oldValue.ReviewStatus, nil
}

// ResetReviewStatus resets all changes to the "review_status" field.
func (m *OrganizationApplicationMutation) ResetReviewStatus() {
	m.review_status = nil
}

// SetReviewComment sets the "review_comment" field.
func (m *OrganizationApplicationMutation) SetReviewComment(s string) {
	m.review_comment = &s
}

// ReviewComment returns the value of the "review_comment" field in the mutation.
func (m *OrganizationApplicationMutation) ReviewComment() (r string, exists bool) {
	v := m.review_comment
	if v == nil {
		return
	}
	return *v, true
}

// OldReviewComment returns the old "review_comment" field's value of the OrganizationApplication entity.
// If the OrganizationApplication object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrganizationApplicationMutation) OldReviewComment(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldReviewComment is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldReviewComment requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldReviewComment: %w", err)
	}
	return oldValue.ReviewComment, nil
}

// ResetReviewComment resets all changes to the "review_comment" field.
func (m *OrganizationApplicationMutation) ResetReviewComment() {
	m.review_comment = nil
}

// SetUserID sets the "user_id" field.
func (m *OrganizationApplicationMutation) SetUserID(s string) {
	m.user_id = &s
}

// UserID returns the value of the "user_id" field in the mutation.
func (m *OrganizationApplicationMutation) UserID() (r string, exists bool) {
	v := m.user_id
	if v == nil {
		return
	}
	return *v, true
}

// OldUserID returns the old "user_id" field's value of the OrganizationApplication entity.
// If the OrganizationApplication object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrganizationApplicationMutation) OldUserID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserID: %w", err)
	}
	return oldValue.UserID, nil
}

// ResetUserID resets all changes to the "user_id" field.
func (m *OrganizationApplicationMutation) ResetUserID() {
	m.user_id = nil
}

// SetBrandShortName sets the "brand_short_name" field.
func (m *OrganizationApplicationMutation) SetBrandShortName(s string) {
	m.brand_short_name = &s
}

// BrandShortName returns the value of the "brand_short_name" field in the mutation.
func (m *OrganizationApplicationMutation) BrandShortName() (r string, exists bool) {
	v := m.brand_short_name
	if v == nil {
		return
	}
	return *v, true
}

// OldBrandShortName returns the old "brand_short_name" field's value of the OrganizationApplication entity.
// If the OrganizationApplication object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrganizationApplicationMutation) OldBrandShortName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBrandShortName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBrandShortName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBrandShortName: %w", err)
	}
	return oldValue.BrandShortName, nil
}

// ResetBrandShortName resets all changes to the "brand_short_name" field.
func (m *OrganizationApplicationMutation) ResetBrandShortName() {
	m.brand_short_name = nil
}

// SetPrimaryBusiness sets the "primary_business" field.
func (m *OrganizationApplicationMutation) SetPrimaryBusiness(s string) {
	m.primary_business = &s
}

// PrimaryBusiness returns the value of the "primary_business" field in the mutation.
func (m *OrganizationApplicationMutation) PrimaryBusiness() (r string, exists bool) {
	v := m.primary_business
	if v == nil {
		return
	}
	return *v, true
}

// OldPrimaryBusiness returns the old "primary_business" field's value of the OrganizationApplication entity.
// If the OrganizationApplication object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrganizationApplicationMutation) OldPrimaryBusiness(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPrimaryBusiness is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPrimaryBusiness requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPrimaryBusiness: %w", err)
	}
	return oldValue.PrimaryBusiness, nil
}

// ResetPrimaryBusiness resets all changes to the "primary_business" field.
func (m *OrganizationApplicationMutation) ResetPrimaryBusiness() {
	m.primary_business = nil
}

// SetUsageScenario sets the "usage_scenario" field.
func (m *OrganizationApplicationMutation) SetUsageScenario(s string) {
	m.usage_scenario = &s
}

// UsageScenario returns the value of the "usage_scenario" field in the mutation.
func (m *OrganizationApplicationMutation) UsageScenario() (r string, exists bool) {
	v := m.usage_scenario
	if v == nil {
		return
	}
	return *v, true
}

// OldUsageScenario returns the old "usage_scenario" field's value of the OrganizationApplication entity.
// If the OrganizationApplication object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrganizationApplicationMutation) OldUsageScenario(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUsageScenario is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUsageScenario requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUsageScenario: %w", err)
	}
	return oldValue.UsageScenario, nil
}

// ResetUsageScenario resets all changes to the "usage_scenario" field.
func (m *OrganizationApplicationMutation) ResetUsageScenario() {
	m.usage_scenario = nil
}

// SetReferrerName sets the "referrer_name" field.
func (m *OrganizationApplicationMutation) SetReferrerName(s string) {
	m.referrer_name = &s
}

// ReferrerName returns the value of the "referrer_name" field in the mutation.
func (m *OrganizationApplicationMutation) ReferrerName() (r string, exists bool) {
	v := m.referrer_name
	if v == nil {
		return
	}
	return *v, true
}

// OldReferrerName returns the old "referrer_name" field's value of the OrganizationApplication entity.
// If the OrganizationApplication object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrganizationApplicationMutation) OldReferrerName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldReferrerName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldReferrerName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldReferrerName: %w", err)
	}
	return oldValue.ReferrerName, nil
}

// ClearReferrerName clears the value of the "referrer_name" field.
func (m *OrganizationApplicationMutation) ClearReferrerName() {
	m.referrer_name = nil
	m.clearedFields[organizationapplication.FieldReferrerName] = struct{}{}
}

// ReferrerNameCleared returns if the "referrer_name" field was cleared in this mutation.
func (m *OrganizationApplicationMutation) ReferrerNameCleared() bool {
	_, ok := m.clearedFields[organizationapplication.FieldReferrerName]
	return ok
}

// ResetReferrerName resets all changes to the "referrer_name" field.
func (m *OrganizationApplicationMutation) ResetReferrerName() {
	m.referrer_name = nil
	delete(m.clearedFields, organizationapplication.FieldReferrerName)
}

// SetDiscoveryWay sets the "discovery_way" field.
func (m *OrganizationApplicationMutation) SetDiscoveryWay(s string) {
	m.discovery_way = &s
}

// DiscoveryWay returns the value of the "discovery_way" field in the mutation.
func (m *OrganizationApplicationMutation) DiscoveryWay() (r string, exists bool) {
	v := m.discovery_way
	if v == nil {
		return
	}
	return *v, true
}

// OldDiscoveryWay returns the old "discovery_way" field's value of the OrganizationApplication entity.
// If the OrganizationApplication object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrganizationApplicationMutation) OldDiscoveryWay(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDiscoveryWay is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDiscoveryWay requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDiscoveryWay: %w", err)
	}
	return oldValue.DiscoveryWay, nil
}

// ClearDiscoveryWay clears the value of the "discovery_way" field.
func (m *OrganizationApplicationMutation) ClearDiscoveryWay() {
	m.discovery_way = nil
	m.clearedFields[organizationapplication.FieldDiscoveryWay] = struct{}{}
}

// DiscoveryWayCleared returns if the "discovery_way" field was cleared in this mutation.
func (m *OrganizationApplicationMutation) DiscoveryWayCleared() bool {
	_, ok := m.clearedFields[organizationapplication.FieldDiscoveryWay]
	return ok
}

// ResetDiscoveryWay resets all changes to the "discovery_way" field.
func (m *OrganizationApplicationMutation) ResetDiscoveryWay() {
	m.discovery_way = nil
	delete(m.clearedFields, organizationapplication.FieldDiscoveryWay)
}

// SetOrgRoleName sets the "org_role_name" field.
func (m *OrganizationApplicationMutation) SetOrgRoleName(s string) {
	m.org_role_name = &s
}

// OrgRoleName returns the value of the "org_role_name" field in the mutation.
func (m *OrganizationApplicationMutation) OrgRoleName() (r string, exists bool) {
	v := m.org_role_name
	if v == nil {
		return
	}
	return *v, true
}

// OldOrgRoleName returns the old "org_role_name" field's value of the OrganizationApplication entity.
// If the OrganizationApplication object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrganizationApplicationMutation) OldOrgRoleName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOrgRoleName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOrgRoleName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOrgRoleName: %w", err)
	}
	return oldValue.OrgRoleName, nil
}

// ResetOrgRoleName resets all changes to the "org_role_name" field.
func (m *OrganizationApplicationMutation) ResetOrgRoleName() {
	m.org_role_name = nil
}

// ClearApplication clears the "application" edge to the Application entity.
func (m *OrganizationApplicationMutation) ClearApplication() {
	m.clearedapplication = true
	m.clearedFields[organizationapplication.FieldApplicationID] = struct{}{}
}

// ApplicationCleared reports if the "application" edge to the Application entity was cleared.
func (m *OrganizationApplicationMutation) ApplicationCleared() bool {
	return m.clearedapplication
}

// ApplicationIDs returns the "application" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ApplicationID instead. It exists only for internal usage by the builders.
func (m *OrganizationApplicationMutation) ApplicationIDs() (ids []uuid.UUID) {
	if id := m.application; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetApplication resets all changes to the "application" edge.
func (m *OrganizationApplicationMutation) ResetApplication() {
	m.application = nil
	m.clearedapplication = false
}

// Where appends a list predicates to the OrganizationApplicationMutation builder.
func (m *OrganizationApplicationMutation) Where(ps ...predicate.OrganizationApplication) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the OrganizationApplicationMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *OrganizationApplicationMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.OrganizationApplication, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *OrganizationApplicationMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *OrganizationApplicationMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (OrganizationApplication).
func (m *OrganizationApplicationMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *OrganizationApplicationMutation) Fields() []string {
	fields := make([]string, 0, 16)
	if m.created_at != nil {
		fields = append(fields, organizationapplication.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, organizationapplication.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, organizationapplication.FieldDeletedAt)
	}
	if m.application != nil {
		fields = append(fields, organizationapplication.FieldApplicationID)
	}
	if m.name != nil {
		fields = append(fields, organizationapplication.FieldName)
	}
	if m.status != nil {
		fields = append(fields, organizationapplication.FieldStatus)
	}
	if m.trial_days != nil {
		fields = append(fields, organizationapplication.FieldTrialDays)
	}
	if m.review_status != nil {
		fields = append(fields, organizationapplication.FieldReviewStatus)
	}
	if m.review_comment != nil {
		fields = append(fields, organizationapplication.FieldReviewComment)
	}
	if m.user_id != nil {
		fields = append(fields, organizationapplication.FieldUserID)
	}
	if m.brand_short_name != nil {
		fields = append(fields, organizationapplication.FieldBrandShortName)
	}
	if m.primary_business != nil {
		fields = append(fields, organizationapplication.FieldPrimaryBusiness)
	}
	if m.usage_scenario != nil {
		fields = append(fields, organizationapplication.FieldUsageScenario)
	}
	if m.referrer_name != nil {
		fields = append(fields, organizationapplication.FieldReferrerName)
	}
	if m.discovery_way != nil {
		fields = append(fields, organizationapplication.FieldDiscoveryWay)
	}
	if m.org_role_name != nil {
		fields = append(fields, organizationapplication.FieldOrgRoleName)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *OrganizationApplicationMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case organizationapplication.FieldCreatedAt:
		return m.CreatedAt()
	case organizationapplication.FieldUpdatedAt:
		return m.UpdatedAt()
	case organizationapplication.FieldDeletedAt:
		return m.DeletedAt()
	case organizationapplication.FieldApplicationID:
		return m.ApplicationID()
	case organizationapplication.FieldName:
		return m.Name()
	case organizationapplication.FieldStatus:
		return m.Status()
	case organizationapplication.FieldTrialDays:
		return m.TrialDays()
	case organizationapplication.FieldReviewStatus:
		return m.ReviewStatus()
	case organizationapplication.FieldReviewComment:
		return m.ReviewComment()
	case organizationapplication.FieldUserID:
		return m.UserID()
	case organizationapplication.FieldBrandShortName:
		return m.BrandShortName()
	case organizationapplication.FieldPrimaryBusiness:
		return m.PrimaryBusiness()
	case organizationapplication.FieldUsageScenario:
		return m.UsageScenario()
	case organizationapplication.FieldReferrerName:
		return m.ReferrerName()
	case organizationapplication.FieldDiscoveryWay:
		return m.DiscoveryWay()
	case organizationapplication.FieldOrgRoleName:
		return m.OrgRoleName()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *OrganizationApplicationMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case organizationapplication.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case organizationapplication.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case organizationapplication.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case organizationapplication.FieldApplicationID:
		return m.OldApplicationID(ctx)
	case organizationapplication.FieldName:
		return m.OldName(ctx)
	case organizationapplication.FieldStatus:
		return m.OldStatus(ctx)
	case organizationapplication.FieldTrialDays:
		return m.OldTrialDays(ctx)
	case organizationapplication.FieldReviewStatus:
		return m.OldReviewStatus(ctx)
	case organizationapplication.FieldReviewComment:
		return m.OldReviewComment(ctx)
	case organizationapplication.FieldUserID:
		return m.OldUserID(ctx)
	case organizationapplication.FieldBrandShortName:
		return m.OldBrandShortName(ctx)
	case organizationapplication.FieldPrimaryBusiness:
		return m.OldPrimaryBusiness(ctx)
	case organizationapplication.FieldUsageScenario:
		return m.OldUsageScenario(ctx)
	case organizationapplication.FieldReferrerName:
		return m.OldReferrerName(ctx)
	case organizationapplication.FieldDiscoveryWay:
		return m.OldDiscoveryWay(ctx)
	case organizationapplication.FieldOrgRoleName:
		return m.OldOrgRoleName(ctx)
	}
	return nil, fmt.Errorf("unknown OrganizationApplication field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *OrganizationApplicationMutation) SetField(name string, value ent.Value) error {
	switch name {
	case organizationapplication.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case organizationapplication.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case organizationapplication.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case organizationapplication.FieldApplicationID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetApplicationID(v)
		return nil
	case organizationapplication.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case organizationapplication.FieldStatus:
		v, ok := value.(organizationapplication.Status)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case organizationapplication.FieldTrialDays:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTrialDays(v)
		return nil
	case organizationapplication.FieldReviewStatus:
		v, ok := value.(organizationapplication.ReviewStatus)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetReviewStatus(v)
		return nil
	case organizationapplication.FieldReviewComment:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetReviewComment(v)
		return nil
	case organizationapplication.FieldUserID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserID(v)
		return nil
	case organizationapplication.FieldBrandShortName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBrandShortName(v)
		return nil
	case organizationapplication.FieldPrimaryBusiness:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPrimaryBusiness(v)
		return nil
	case organizationapplication.FieldUsageScenario:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUsageScenario(v)
		return nil
	case organizationapplication.FieldReferrerName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetReferrerName(v)
		return nil
	case organizationapplication.FieldDiscoveryWay:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDiscoveryWay(v)
		return nil
	case organizationapplication.FieldOrgRoleName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOrgRoleName(v)
		return nil
	}
	return fmt.Errorf("unknown OrganizationApplication field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *OrganizationApplicationMutation) AddedFields() []string {
	var fields []string
	if m.addtrial_days != nil {
		fields = append(fields, organizationapplication.FieldTrialDays)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *OrganizationApplicationMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case organizationapplication.FieldTrialDays:
		return m.AddedTrialDays()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *OrganizationApplicationMutation) AddField(name string, value ent.Value) error {
	switch name {
	case organizationapplication.FieldTrialDays:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTrialDays(v)
		return nil
	}
	return fmt.Errorf("unknown OrganizationApplication numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *OrganizationApplicationMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(organizationapplication.FieldDeletedAt) {
		fields = append(fields, organizationapplication.FieldDeletedAt)
	}
	if m.FieldCleared(organizationapplication.FieldTrialDays) {
		fields = append(fields, organizationapplication.FieldTrialDays)
	}
	if m.FieldCleared(organizationapplication.FieldReferrerName) {
		fields = append(fields, organizationapplication.FieldReferrerName)
	}
	if m.FieldCleared(organizationapplication.FieldDiscoveryWay) {
		fields = append(fields, organizationapplication.FieldDiscoveryWay)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *OrganizationApplicationMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *OrganizationApplicationMutation) ClearField(name string) error {
	switch name {
	case organizationapplication.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case organizationapplication.FieldTrialDays:
		m.ClearTrialDays()
		return nil
	case organizationapplication.FieldReferrerName:
		m.ClearReferrerName()
		return nil
	case organizationapplication.FieldDiscoveryWay:
		m.ClearDiscoveryWay()
		return nil
	}
	return fmt.Errorf("unknown OrganizationApplication nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *OrganizationApplicationMutation) ResetField(name string) error {
	switch name {
	case organizationapplication.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case organizationapplication.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case organizationapplication.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case organizationapplication.FieldApplicationID:
		m.ResetApplicationID()
		return nil
	case organizationapplication.FieldName:
		m.ResetName()
		return nil
	case organizationapplication.FieldStatus:
		m.ResetStatus()
		return nil
	case organizationapplication.FieldTrialDays:
		m.ResetTrialDays()
		return nil
	case organizationapplication.FieldReviewStatus:
		m.ResetReviewStatus()
		return nil
	case organizationapplication.FieldReviewComment:
		m.ResetReviewComment()
		return nil
	case organizationapplication.FieldUserID:
		m.ResetUserID()
		return nil
	case organizationapplication.FieldBrandShortName:
		m.ResetBrandShortName()
		return nil
	case organizationapplication.FieldPrimaryBusiness:
		m.ResetPrimaryBusiness()
		return nil
	case organizationapplication.FieldUsageScenario:
		m.ResetUsageScenario()
		return nil
	case organizationapplication.FieldReferrerName:
		m.ResetReferrerName()
		return nil
	case organizationapplication.FieldDiscoveryWay:
		m.ResetDiscoveryWay()
		return nil
	case organizationapplication.FieldOrgRoleName:
		m.ResetOrgRoleName()
		return nil
	}
	return fmt.Errorf("unknown OrganizationApplication field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *OrganizationApplicationMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.application != nil {
		edges = append(edges, organizationapplication.EdgeApplication)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *OrganizationApplicationMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case organizationapplication.EdgeApplication:
		if id := m.application; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *OrganizationApplicationMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *OrganizationApplicationMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *OrganizationApplicationMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedapplication {
		edges = append(edges, organizationapplication.EdgeApplication)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *OrganizationApplicationMutation) EdgeCleared(name string) bool {
	switch name {
	case organizationapplication.EdgeApplication:
		return m.clearedapplication
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *OrganizationApplicationMutation) ClearEdge(name string) error {
	switch name {
	case organizationapplication.EdgeApplication:
		m.ClearApplication()
		return nil
	}
	return fmt.Errorf("unknown OrganizationApplication unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *OrganizationApplicationMutation) ResetEdge(name string) error {
	switch name {
	case organizationapplication.EdgeApplication:
		m.ResetApplication()
		return nil
	}
	return fmt.Errorf("unknown OrganizationApplication edge %s", name)
}

// OrganizationRequestMutation represents an operation that mutates the OrganizationRequest nodes in the graph.
type OrganizationRequestMutation struct {
	config
	op                Op
	typ               string
	id                *uuid.UUID
	created_at        *time.Time
	updated_at        *time.Time
	deleted_at        *time.Time
	_type             *organizationrequest.Type
	status            *organizationrequest.Status
	user_id           *string
	organization_id   *uuid.UUID
	organization_name *string
	clearedFields     map[string]struct{}
	done              bool
	oldValue          func(context.Context) (*OrganizationRequest, error)
	predicates        []predicate.OrganizationRequest
}

var _ ent.Mutation = (*OrganizationRequestMutation)(nil)

// organizationrequestOption allows management of the mutation configuration using functional options.
type organizationrequestOption func(*OrganizationRequestMutation)

// newOrganizationRequestMutation creates new mutation for the OrganizationRequest entity.
func newOrganizationRequestMutation(c config, op Op, opts ...organizationrequestOption) *OrganizationRequestMutation {
	m := &OrganizationRequestMutation{
		config:        c,
		op:            op,
		typ:           TypeOrganizationRequest,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withOrganizationRequestID sets the ID field of the mutation.
func withOrganizationRequestID(id uuid.UUID) organizationrequestOption {
	return func(m *OrganizationRequestMutation) {
		var (
			err   error
			once  sync.Once
			value *OrganizationRequest
		)
		m.oldValue = func(ctx context.Context) (*OrganizationRequest, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().OrganizationRequest.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withOrganizationRequest sets the old OrganizationRequest of the mutation.
func withOrganizationRequest(node *OrganizationRequest) organizationrequestOption {
	return func(m *OrganizationRequestMutation) {
		m.oldValue = func(context.Context) (*OrganizationRequest, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m OrganizationRequestMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m OrganizationRequestMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of OrganizationRequest entities.
func (m *OrganizationRequestMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *OrganizationRequestMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *OrganizationRequestMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().OrganizationRequest.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *OrganizationRequestMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *OrganizationRequestMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the OrganizationRequest entity.
// If the OrganizationRequest object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrganizationRequestMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *OrganizationRequestMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *OrganizationRequestMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *OrganizationRequestMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the OrganizationRequest entity.
// If the OrganizationRequest object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrganizationRequestMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *OrganizationRequestMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *OrganizationRequestMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *OrganizationRequestMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the OrganizationRequest entity.
// If the OrganizationRequest object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrganizationRequestMutation) OldDeletedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *OrganizationRequestMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[organizationrequest.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *OrganizationRequestMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[organizationrequest.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *OrganizationRequestMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, organizationrequest.FieldDeletedAt)
}

// SetType sets the "type" field.
func (m *OrganizationRequestMutation) SetType(o organizationrequest.Type) {
	m._type = &o
}

// GetType returns the value of the "type" field in the mutation.
func (m *OrganizationRequestMutation) GetType() (r organizationrequest.Type, exists bool) {
	v := m._type
	if v == nil {
		return
	}
	return *v, true
}

// OldType returns the old "type" field's value of the OrganizationRequest entity.
// If the OrganizationRequest object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrganizationRequestMutation) OldType(ctx context.Context) (v organizationrequest.Type, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldType: %w", err)
	}
	return oldValue.Type, nil
}

// ResetType resets all changes to the "type" field.
func (m *OrganizationRequestMutation) ResetType() {
	m._type = nil
}

// SetStatus sets the "status" field.
func (m *OrganizationRequestMutation) SetStatus(o organizationrequest.Status) {
	m.status = &o
}

// Status returns the value of the "status" field in the mutation.
func (m *OrganizationRequestMutation) Status() (r organizationrequest.Status, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the OrganizationRequest entity.
// If the OrganizationRequest object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrganizationRequestMutation) OldStatus(ctx context.Context) (v organizationrequest.Status, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *OrganizationRequestMutation) ResetStatus() {
	m.status = nil
}

// SetUserID sets the "user_id" field.
func (m *OrganizationRequestMutation) SetUserID(s string) {
	m.user_id = &s
}

// UserID returns the value of the "user_id" field in the mutation.
func (m *OrganizationRequestMutation) UserID() (r string, exists bool) {
	v := m.user_id
	if v == nil {
		return
	}
	return *v, true
}

// OldUserID returns the old "user_id" field's value of the OrganizationRequest entity.
// If the OrganizationRequest object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrganizationRequestMutation) OldUserID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserID: %w", err)
	}
	return oldValue.UserID, nil
}

// ResetUserID resets all changes to the "user_id" field.
func (m *OrganizationRequestMutation) ResetUserID() {
	m.user_id = nil
}

// SetOrganizationID sets the "organization_id" field.
func (m *OrganizationRequestMutation) SetOrganizationID(u uuid.UUID) {
	m.organization_id = &u
}

// OrganizationID returns the value of the "organization_id" field in the mutation.
func (m *OrganizationRequestMutation) OrganizationID() (r uuid.UUID, exists bool) {
	v := m.organization_id
	if v == nil {
		return
	}
	return *v, true
}

// OldOrganizationID returns the old "organization_id" field's value of the OrganizationRequest entity.
// If the OrganizationRequest object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrganizationRequestMutation) OldOrganizationID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOrganizationID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOrganizationID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOrganizationID: %w", err)
	}
	return oldValue.OrganizationID, nil
}

// ResetOrganizationID resets all changes to the "organization_id" field.
func (m *OrganizationRequestMutation) ResetOrganizationID() {
	m.organization_id = nil
}

// SetOrganizationName sets the "organization_name" field.
func (m *OrganizationRequestMutation) SetOrganizationName(s string) {
	m.organization_name = &s
}

// OrganizationName returns the value of the "organization_name" field in the mutation.
func (m *OrganizationRequestMutation) OrganizationName() (r string, exists bool) {
	v := m.organization_name
	if v == nil {
		return
	}
	return *v, true
}

// OldOrganizationName returns the old "organization_name" field's value of the OrganizationRequest entity.
// If the OrganizationRequest object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrganizationRequestMutation) OldOrganizationName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOrganizationName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOrganizationName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOrganizationName: %w", err)
	}
	return oldValue.OrganizationName, nil
}

// ResetOrganizationName resets all changes to the "organization_name" field.
func (m *OrganizationRequestMutation) ResetOrganizationName() {
	m.organization_name = nil
}

// Where appends a list predicates to the OrganizationRequestMutation builder.
func (m *OrganizationRequestMutation) Where(ps ...predicate.OrganizationRequest) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the OrganizationRequestMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *OrganizationRequestMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.OrganizationRequest, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *OrganizationRequestMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *OrganizationRequestMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (OrganizationRequest).
func (m *OrganizationRequestMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *OrganizationRequestMutation) Fields() []string {
	fields := make([]string, 0, 8)
	if m.created_at != nil {
		fields = append(fields, organizationrequest.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, organizationrequest.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, organizationrequest.FieldDeletedAt)
	}
	if m._type != nil {
		fields = append(fields, organizationrequest.FieldType)
	}
	if m.status != nil {
		fields = append(fields, organizationrequest.FieldStatus)
	}
	if m.user_id != nil {
		fields = append(fields, organizationrequest.FieldUserID)
	}
	if m.organization_id != nil {
		fields = append(fields, organizationrequest.FieldOrganizationID)
	}
	if m.organization_name != nil {
		fields = append(fields, organizationrequest.FieldOrganizationName)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *OrganizationRequestMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case organizationrequest.FieldCreatedAt:
		return m.CreatedAt()
	case organizationrequest.FieldUpdatedAt:
		return m.UpdatedAt()
	case organizationrequest.FieldDeletedAt:
		return m.DeletedAt()
	case organizationrequest.FieldType:
		return m.GetType()
	case organizationrequest.FieldStatus:
		return m.Status()
	case organizationrequest.FieldUserID:
		return m.UserID()
	case organizationrequest.FieldOrganizationID:
		return m.OrganizationID()
	case organizationrequest.FieldOrganizationName:
		return m.OrganizationName()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *OrganizationRequestMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case organizationrequest.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case organizationrequest.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case organizationrequest.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case organizationrequest.FieldType:
		return m.OldType(ctx)
	case organizationrequest.FieldStatus:
		return m.OldStatus(ctx)
	case organizationrequest.FieldUserID:
		return m.OldUserID(ctx)
	case organizationrequest.FieldOrganizationID:
		return m.OldOrganizationID(ctx)
	case organizationrequest.FieldOrganizationName:
		return m.OldOrganizationName(ctx)
	}
	return nil, fmt.Errorf("unknown OrganizationRequest field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *OrganizationRequestMutation) SetField(name string, value ent.Value) error {
	switch name {
	case organizationrequest.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case organizationrequest.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case organizationrequest.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case organizationrequest.FieldType:
		v, ok := value.(organizationrequest.Type)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetType(v)
		return nil
	case organizationrequest.FieldStatus:
		v, ok := value.(organizationrequest.Status)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case organizationrequest.FieldUserID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserID(v)
		return nil
	case organizationrequest.FieldOrganizationID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOrganizationID(v)
		return nil
	case organizationrequest.FieldOrganizationName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOrganizationName(v)
		return nil
	}
	return fmt.Errorf("unknown OrganizationRequest field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *OrganizationRequestMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *OrganizationRequestMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *OrganizationRequestMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown OrganizationRequest numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *OrganizationRequestMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(organizationrequest.FieldDeletedAt) {
		fields = append(fields, organizationrequest.FieldDeletedAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *OrganizationRequestMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *OrganizationRequestMutation) ClearField(name string) error {
	switch name {
	case organizationrequest.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	}
	return fmt.Errorf("unknown OrganizationRequest nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *OrganizationRequestMutation) ResetField(name string) error {
	switch name {
	case organizationrequest.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case organizationrequest.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case organizationrequest.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case organizationrequest.FieldType:
		m.ResetType()
		return nil
	case organizationrequest.FieldStatus:
		m.ResetStatus()
		return nil
	case organizationrequest.FieldUserID:
		m.ResetUserID()
		return nil
	case organizationrequest.FieldOrganizationID:
		m.ResetOrganizationID()
		return nil
	case organizationrequest.FieldOrganizationName:
		m.ResetOrganizationName()
		return nil
	}
	return fmt.Errorf("unknown OrganizationRequest field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *OrganizationRequestMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *OrganizationRequestMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *OrganizationRequestMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *OrganizationRequestMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *OrganizationRequestMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *OrganizationRequestMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *OrganizationRequestMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown OrganizationRequest unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *OrganizationRequestMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown OrganizationRequest edge %s", name)
}

// OrganizationUserMutation represents an operation that mutates the OrganizationUser nodes in the graph.
type OrganizationUserMutation struct {
	config
	op                  Op
	typ                 string
	id                  *uuid.UUID
	created_at          *time.Time
	updated_at          *time.Time
	deleted_at          *time.Time
	clearedFields       map[string]struct{}
	organization        *uuid.UUID
	clearedorganization bool
	user                *string
	cleareduser         bool
	role                *uuid.UUID
	clearedrole         bool
	done                bool
	oldValue            func(context.Context) (*OrganizationUser, error)
	predicates          []predicate.OrganizationUser
}

var _ ent.Mutation = (*OrganizationUserMutation)(nil)

// organizationuserOption allows management of the mutation configuration using functional options.
type organizationuserOption func(*OrganizationUserMutation)

// newOrganizationUserMutation creates new mutation for the OrganizationUser entity.
func newOrganizationUserMutation(c config, op Op, opts ...organizationuserOption) *OrganizationUserMutation {
	m := &OrganizationUserMutation{
		config:        c,
		op:            op,
		typ:           TypeOrganizationUser,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withOrganizationUserID sets the ID field of the mutation.
func withOrganizationUserID(id uuid.UUID) organizationuserOption {
	return func(m *OrganizationUserMutation) {
		var (
			err   error
			once  sync.Once
			value *OrganizationUser
		)
		m.oldValue = func(ctx context.Context) (*OrganizationUser, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().OrganizationUser.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withOrganizationUser sets the old OrganizationUser of the mutation.
func withOrganizationUser(node *OrganizationUser) organizationuserOption {
	return func(m *OrganizationUserMutation) {
		m.oldValue = func(context.Context) (*OrganizationUser, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m OrganizationUserMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m OrganizationUserMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of OrganizationUser entities.
func (m *OrganizationUserMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *OrganizationUserMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *OrganizationUserMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().OrganizationUser.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *OrganizationUserMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *OrganizationUserMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the OrganizationUser entity.
// If the OrganizationUser object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrganizationUserMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *OrganizationUserMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *OrganizationUserMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *OrganizationUserMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the OrganizationUser entity.
// If the OrganizationUser object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrganizationUserMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *OrganizationUserMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *OrganizationUserMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *OrganizationUserMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the OrganizationUser entity.
// If the OrganizationUser object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrganizationUserMutation) OldDeletedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *OrganizationUserMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[organizationuser.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *OrganizationUserMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[organizationuser.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *OrganizationUserMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, organizationuser.FieldDeletedAt)
}

// SetOrganizationID sets the "organization_id" field.
func (m *OrganizationUserMutation) SetOrganizationID(u uuid.UUID) {
	m.organization = &u
}

// OrganizationID returns the value of the "organization_id" field in the mutation.
func (m *OrganizationUserMutation) OrganizationID() (r uuid.UUID, exists bool) {
	v := m.organization
	if v == nil {
		return
	}
	return *v, true
}

// OldOrganizationID returns the old "organization_id" field's value of the OrganizationUser entity.
// If the OrganizationUser object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrganizationUserMutation) OldOrganizationID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOrganizationID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOrganizationID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOrganizationID: %w", err)
	}
	return oldValue.OrganizationID, nil
}

// ResetOrganizationID resets all changes to the "organization_id" field.
func (m *OrganizationUserMutation) ResetOrganizationID() {
	m.organization = nil
}

// SetUserID sets the "user_id" field.
func (m *OrganizationUserMutation) SetUserID(s string) {
	m.user = &s
}

// UserID returns the value of the "user_id" field in the mutation.
func (m *OrganizationUserMutation) UserID() (r string, exists bool) {
	v := m.user
	if v == nil {
		return
	}
	return *v, true
}

// OldUserID returns the old "user_id" field's value of the OrganizationUser entity.
// If the OrganizationUser object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrganizationUserMutation) OldUserID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserID: %w", err)
	}
	return oldValue.UserID, nil
}

// ResetUserID resets all changes to the "user_id" field.
func (m *OrganizationUserMutation) ResetUserID() {
	m.user = nil
}

// ClearOrganization clears the "organization" edge to the Organization entity.
func (m *OrganizationUserMutation) ClearOrganization() {
	m.clearedorganization = true
	m.clearedFields[organizationuser.FieldOrganizationID] = struct{}{}
}

// OrganizationCleared reports if the "organization" edge to the Organization entity was cleared.
func (m *OrganizationUserMutation) OrganizationCleared() bool {
	return m.clearedorganization
}

// OrganizationIDs returns the "organization" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// OrganizationID instead. It exists only for internal usage by the builders.
func (m *OrganizationUserMutation) OrganizationIDs() (ids []uuid.UUID) {
	if id := m.organization; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetOrganization resets all changes to the "organization" edge.
func (m *OrganizationUserMutation) ResetOrganization() {
	m.organization = nil
	m.clearedorganization = false
}

// ClearUser clears the "user" edge to the User entity.
func (m *OrganizationUserMutation) ClearUser() {
	m.cleareduser = true
	m.clearedFields[organizationuser.FieldUserID] = struct{}{}
}

// UserCleared reports if the "user" edge to the User entity was cleared.
func (m *OrganizationUserMutation) UserCleared() bool {
	return m.cleareduser
}

// UserIDs returns the "user" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UserID instead. It exists only for internal usage by the builders.
func (m *OrganizationUserMutation) UserIDs() (ids []string) {
	if id := m.user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUser resets all changes to the "user" edge.
func (m *OrganizationUserMutation) ResetUser() {
	m.user = nil
	m.cleareduser = false
}

// SetRoleID sets the "role" edge to the Role entity by id.
func (m *OrganizationUserMutation) SetRoleID(id uuid.UUID) {
	m.role = &id
}

// ClearRole clears the "role" edge to the Role entity.
func (m *OrganizationUserMutation) ClearRole() {
	m.clearedrole = true
}

// RoleCleared reports if the "role" edge to the Role entity was cleared.
func (m *OrganizationUserMutation) RoleCleared() bool {
	return m.clearedrole
}

// RoleID returns the "role" edge ID in the mutation.
func (m *OrganizationUserMutation) RoleID() (id uuid.UUID, exists bool) {
	if m.role != nil {
		return *m.role, true
	}
	return
}

// RoleIDs returns the "role" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// RoleID instead. It exists only for internal usage by the builders.
func (m *OrganizationUserMutation) RoleIDs() (ids []uuid.UUID) {
	if id := m.role; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetRole resets all changes to the "role" edge.
func (m *OrganizationUserMutation) ResetRole() {
	m.role = nil
	m.clearedrole = false
}

// Where appends a list predicates to the OrganizationUserMutation builder.
func (m *OrganizationUserMutation) Where(ps ...predicate.OrganizationUser) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the OrganizationUserMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *OrganizationUserMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.OrganizationUser, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *OrganizationUserMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *OrganizationUserMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (OrganizationUser).
func (m *OrganizationUserMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *OrganizationUserMutation) Fields() []string {
	fields := make([]string, 0, 5)
	if m.created_at != nil {
		fields = append(fields, organizationuser.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, organizationuser.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, organizationuser.FieldDeletedAt)
	}
	if m.organization != nil {
		fields = append(fields, organizationuser.FieldOrganizationID)
	}
	if m.user != nil {
		fields = append(fields, organizationuser.FieldUserID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *OrganizationUserMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case organizationuser.FieldCreatedAt:
		return m.CreatedAt()
	case organizationuser.FieldUpdatedAt:
		return m.UpdatedAt()
	case organizationuser.FieldDeletedAt:
		return m.DeletedAt()
	case organizationuser.FieldOrganizationID:
		return m.OrganizationID()
	case organizationuser.FieldUserID:
		return m.UserID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *OrganizationUserMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case organizationuser.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case organizationuser.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case organizationuser.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case organizationuser.FieldOrganizationID:
		return m.OldOrganizationID(ctx)
	case organizationuser.FieldUserID:
		return m.OldUserID(ctx)
	}
	return nil, fmt.Errorf("unknown OrganizationUser field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *OrganizationUserMutation) SetField(name string, value ent.Value) error {
	switch name {
	case organizationuser.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case organizationuser.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case organizationuser.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case organizationuser.FieldOrganizationID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOrganizationID(v)
		return nil
	case organizationuser.FieldUserID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserID(v)
		return nil
	}
	return fmt.Errorf("unknown OrganizationUser field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *OrganizationUserMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *OrganizationUserMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *OrganizationUserMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown OrganizationUser numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *OrganizationUserMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(organizationuser.FieldDeletedAt) {
		fields = append(fields, organizationuser.FieldDeletedAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *OrganizationUserMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *OrganizationUserMutation) ClearField(name string) error {
	switch name {
	case organizationuser.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	}
	return fmt.Errorf("unknown OrganizationUser nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *OrganizationUserMutation) ResetField(name string) error {
	switch name {
	case organizationuser.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case organizationuser.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case organizationuser.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case organizationuser.FieldOrganizationID:
		m.ResetOrganizationID()
		return nil
	case organizationuser.FieldUserID:
		m.ResetUserID()
		return nil
	}
	return fmt.Errorf("unknown OrganizationUser field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *OrganizationUserMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.organization != nil {
		edges = append(edges, organizationuser.EdgeOrganization)
	}
	if m.user != nil {
		edges = append(edges, organizationuser.EdgeUser)
	}
	if m.role != nil {
		edges = append(edges, organizationuser.EdgeRole)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *OrganizationUserMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case organizationuser.EdgeOrganization:
		if id := m.organization; id != nil {
			return []ent.Value{*id}
		}
	case organizationuser.EdgeUser:
		if id := m.user; id != nil {
			return []ent.Value{*id}
		}
	case organizationuser.EdgeRole:
		if id := m.role; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *OrganizationUserMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *OrganizationUserMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *OrganizationUserMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.clearedorganization {
		edges = append(edges, organizationuser.EdgeOrganization)
	}
	if m.cleareduser {
		edges = append(edges, organizationuser.EdgeUser)
	}
	if m.clearedrole {
		edges = append(edges, organizationuser.EdgeRole)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *OrganizationUserMutation) EdgeCleared(name string) bool {
	switch name {
	case organizationuser.EdgeOrganization:
		return m.clearedorganization
	case organizationuser.EdgeUser:
		return m.cleareduser
	case organizationuser.EdgeRole:
		return m.clearedrole
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *OrganizationUserMutation) ClearEdge(name string) error {
	switch name {
	case organizationuser.EdgeOrganization:
		m.ClearOrganization()
		return nil
	case organizationuser.EdgeUser:
		m.ClearUser()
		return nil
	case organizationuser.EdgeRole:
		m.ClearRole()
		return nil
	}
	return fmt.Errorf("unknown OrganizationUser unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *OrganizationUserMutation) ResetEdge(name string) error {
	switch name {
	case organizationuser.EdgeOrganization:
		m.ResetOrganization()
		return nil
	case organizationuser.EdgeUser:
		m.ResetUser()
		return nil
	case organizationuser.EdgeRole:
		m.ResetRole()
		return nil
	}
	return fmt.Errorf("unknown OrganizationUser edge %s", name)
}

// PaymentMutation represents an operation that mutates the Payment nodes in the graph.
type PaymentMutation struct {
	config
	op             Op
	typ            string
	id             *int
	created_at     *time.Time
	updated_at     *time.Time
	out_trade_no   *string
	transaction_id *string
	open_id        *string
	channel        *payment.Channel
	platform       *payment.Platform
	service        *string
	amount         *int
	addamount      *int
	currency       *string
	description    *string
	status         *payment.Status
	paid_at        *time.Time
	clearedFields  map[string]struct{}
	user           *string
	cleareduser    bool
	done           bool
	oldValue       func(context.Context) (*Payment, error)
	predicates     []predicate.Payment
}

var _ ent.Mutation = (*PaymentMutation)(nil)

// paymentOption allows management of the mutation configuration using functional options.
type paymentOption func(*PaymentMutation)

// newPaymentMutation creates new mutation for the Payment entity.
func newPaymentMutation(c config, op Op, opts ...paymentOption) *PaymentMutation {
	m := &PaymentMutation{
		config:        c,
		op:            op,
		typ:           TypePayment,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withPaymentID sets the ID field of the mutation.
func withPaymentID(id int) paymentOption {
	return func(m *PaymentMutation) {
		var (
			err   error
			once  sync.Once
			value *Payment
		)
		m.oldValue = func(ctx context.Context) (*Payment, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Payment.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withPayment sets the old Payment of the mutation.
func withPayment(node *Payment) paymentOption {
	return func(m *PaymentMutation) {
		m.oldValue = func(context.Context) (*Payment, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m PaymentMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m PaymentMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *PaymentMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *PaymentMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Payment.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *PaymentMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *PaymentMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Payment entity.
// If the Payment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PaymentMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *PaymentMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *PaymentMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *PaymentMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Payment entity.
// If the Payment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PaymentMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *PaymentMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetOutTradeNo sets the "out_trade_no" field.
func (m *PaymentMutation) SetOutTradeNo(s string) {
	m.out_trade_no = &s
}

// OutTradeNo returns the value of the "out_trade_no" field in the mutation.
func (m *PaymentMutation) OutTradeNo() (r string, exists bool) {
	v := m.out_trade_no
	if v == nil {
		return
	}
	return *v, true
}

// OldOutTradeNo returns the old "out_trade_no" field's value of the Payment entity.
// If the Payment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PaymentMutation) OldOutTradeNo(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOutTradeNo is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOutTradeNo requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOutTradeNo: %w", err)
	}
	return oldValue.OutTradeNo, nil
}

// ResetOutTradeNo resets all changes to the "out_trade_no" field.
func (m *PaymentMutation) ResetOutTradeNo() {
	m.out_trade_no = nil
}

// SetUserID sets the "user_id" field.
func (m *PaymentMutation) SetUserID(s string) {
	m.user = &s
}

// UserID returns the value of the "user_id" field in the mutation.
func (m *PaymentMutation) UserID() (r string, exists bool) {
	v := m.user
	if v == nil {
		return
	}
	return *v, true
}

// OldUserID returns the old "user_id" field's value of the Payment entity.
// If the Payment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PaymentMutation) OldUserID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserID: %w", err)
	}
	return oldValue.UserID, nil
}

// ResetUserID resets all changes to the "user_id" field.
func (m *PaymentMutation) ResetUserID() {
	m.user = nil
}

// SetTransactionID sets the "transaction_id" field.
func (m *PaymentMutation) SetTransactionID(s string) {
	m.transaction_id = &s
}

// TransactionID returns the value of the "transaction_id" field in the mutation.
func (m *PaymentMutation) TransactionID() (r string, exists bool) {
	v := m.transaction_id
	if v == nil {
		return
	}
	return *v, true
}

// OldTransactionID returns the old "transaction_id" field's value of the Payment entity.
// If the Payment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PaymentMutation) OldTransactionID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTransactionID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTransactionID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTransactionID: %w", err)
	}
	return oldValue.TransactionID, nil
}

// ClearTransactionID clears the value of the "transaction_id" field.
func (m *PaymentMutation) ClearTransactionID() {
	m.transaction_id = nil
	m.clearedFields[payment.FieldTransactionID] = struct{}{}
}

// TransactionIDCleared returns if the "transaction_id" field was cleared in this mutation.
func (m *PaymentMutation) TransactionIDCleared() bool {
	_, ok := m.clearedFields[payment.FieldTransactionID]
	return ok
}

// ResetTransactionID resets all changes to the "transaction_id" field.
func (m *PaymentMutation) ResetTransactionID() {
	m.transaction_id = nil
	delete(m.clearedFields, payment.FieldTransactionID)
}

// SetOpenID sets the "open_id" field.
func (m *PaymentMutation) SetOpenID(s string) {
	m.open_id = &s
}

// OpenID returns the value of the "open_id" field in the mutation.
func (m *PaymentMutation) OpenID() (r string, exists bool) {
	v := m.open_id
	if v == nil {
		return
	}
	return *v, true
}

// OldOpenID returns the old "open_id" field's value of the Payment entity.
// If the Payment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PaymentMutation) OldOpenID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOpenID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOpenID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOpenID: %w", err)
	}
	return oldValue.OpenID, nil
}

// ClearOpenID clears the value of the "open_id" field.
func (m *PaymentMutation) ClearOpenID() {
	m.open_id = nil
	m.clearedFields[payment.FieldOpenID] = struct{}{}
}

// OpenIDCleared returns if the "open_id" field was cleared in this mutation.
func (m *PaymentMutation) OpenIDCleared() bool {
	_, ok := m.clearedFields[payment.FieldOpenID]
	return ok
}

// ResetOpenID resets all changes to the "open_id" field.
func (m *PaymentMutation) ResetOpenID() {
	m.open_id = nil
	delete(m.clearedFields, payment.FieldOpenID)
}

// SetChannel sets the "channel" field.
func (m *PaymentMutation) SetChannel(pa payment.Channel) {
	m.channel = &pa
}

// Channel returns the value of the "channel" field in the mutation.
func (m *PaymentMutation) Channel() (r payment.Channel, exists bool) {
	v := m.channel
	if v == nil {
		return
	}
	return *v, true
}

// OldChannel returns the old "channel" field's value of the Payment entity.
// If the Payment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PaymentMutation) OldChannel(ctx context.Context) (v payment.Channel, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldChannel is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldChannel requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldChannel: %w", err)
	}
	return oldValue.Channel, nil
}

// ResetChannel resets all changes to the "channel" field.
func (m *PaymentMutation) ResetChannel() {
	m.channel = nil
}

// SetPlatform sets the "platform" field.
func (m *PaymentMutation) SetPlatform(pa payment.Platform) {
	m.platform = &pa
}

// Platform returns the value of the "platform" field in the mutation.
func (m *PaymentMutation) Platform() (r payment.Platform, exists bool) {
	v := m.platform
	if v == nil {
		return
	}
	return *v, true
}

// OldPlatform returns the old "platform" field's value of the Payment entity.
// If the Payment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PaymentMutation) OldPlatform(ctx context.Context) (v payment.Platform, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPlatform is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPlatform requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPlatform: %w", err)
	}
	return oldValue.Platform, nil
}

// ResetPlatform resets all changes to the "platform" field.
func (m *PaymentMutation) ResetPlatform() {
	m.platform = nil
}

// SetService sets the "service" field.
func (m *PaymentMutation) SetService(s string) {
	m.service = &s
}

// Service returns the value of the "service" field in the mutation.
func (m *PaymentMutation) Service() (r string, exists bool) {
	v := m.service
	if v == nil {
		return
	}
	return *v, true
}

// OldService returns the old "service" field's value of the Payment entity.
// If the Payment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PaymentMutation) OldService(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldService is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldService requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldService: %w", err)
	}
	return oldValue.Service, nil
}

// ResetService resets all changes to the "service" field.
func (m *PaymentMutation) ResetService() {
	m.service = nil
}

// SetAmount sets the "amount" field.
func (m *PaymentMutation) SetAmount(i int) {
	m.amount = &i
	m.addamount = nil
}

// Amount returns the value of the "amount" field in the mutation.
func (m *PaymentMutation) Amount() (r int, exists bool) {
	v := m.amount
	if v == nil {
		return
	}
	return *v, true
}

// OldAmount returns the old "amount" field's value of the Payment entity.
// If the Payment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PaymentMutation) OldAmount(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAmount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAmount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAmount: %w", err)
	}
	return oldValue.Amount, nil
}

// AddAmount adds i to the "amount" field.
func (m *PaymentMutation) AddAmount(i int) {
	if m.addamount != nil {
		*m.addamount += i
	} else {
		m.addamount = &i
	}
}

// AddedAmount returns the value that was added to the "amount" field in this mutation.
func (m *PaymentMutation) AddedAmount() (r int, exists bool) {
	v := m.addamount
	if v == nil {
		return
	}
	return *v, true
}

// ResetAmount resets all changes to the "amount" field.
func (m *PaymentMutation) ResetAmount() {
	m.amount = nil
	m.addamount = nil
}

// SetCurrency sets the "currency" field.
func (m *PaymentMutation) SetCurrency(s string) {
	m.currency = &s
}

// Currency returns the value of the "currency" field in the mutation.
func (m *PaymentMutation) Currency() (r string, exists bool) {
	v := m.currency
	if v == nil {
		return
	}
	return *v, true
}

// OldCurrency returns the old "currency" field's value of the Payment entity.
// If the Payment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PaymentMutation) OldCurrency(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCurrency is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCurrency requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCurrency: %w", err)
	}
	return oldValue.Currency, nil
}

// ResetCurrency resets all changes to the "currency" field.
func (m *PaymentMutation) ResetCurrency() {
	m.currency = nil
}

// SetDescription sets the "description" field.
func (m *PaymentMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *PaymentMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the Payment entity.
// If the Payment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PaymentMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ResetDescription resets all changes to the "description" field.
func (m *PaymentMutation) ResetDescription() {
	m.description = nil
}

// SetStatus sets the "status" field.
func (m *PaymentMutation) SetStatus(pa payment.Status) {
	m.status = &pa
}

// Status returns the value of the "status" field in the mutation.
func (m *PaymentMutation) Status() (r payment.Status, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the Payment entity.
// If the Payment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PaymentMutation) OldStatus(ctx context.Context) (v payment.Status, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *PaymentMutation) ResetStatus() {
	m.status = nil
}

// SetPaidAt sets the "paid_at" field.
func (m *PaymentMutation) SetPaidAt(t time.Time) {
	m.paid_at = &t
}

// PaidAt returns the value of the "paid_at" field in the mutation.
func (m *PaymentMutation) PaidAt() (r time.Time, exists bool) {
	v := m.paid_at
	if v == nil {
		return
	}
	return *v, true
}

// OldPaidAt returns the old "paid_at" field's value of the Payment entity.
// If the Payment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PaymentMutation) OldPaidAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPaidAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPaidAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPaidAt: %w", err)
	}
	return oldValue.PaidAt, nil
}

// ClearPaidAt clears the value of the "paid_at" field.
func (m *PaymentMutation) ClearPaidAt() {
	m.paid_at = nil
	m.clearedFields[payment.FieldPaidAt] = struct{}{}
}

// PaidAtCleared returns if the "paid_at" field was cleared in this mutation.
func (m *PaymentMutation) PaidAtCleared() bool {
	_, ok := m.clearedFields[payment.FieldPaidAt]
	return ok
}

// ResetPaidAt resets all changes to the "paid_at" field.
func (m *PaymentMutation) ResetPaidAt() {
	m.paid_at = nil
	delete(m.clearedFields, payment.FieldPaidAt)
}

// ClearUser clears the "user" edge to the User entity.
func (m *PaymentMutation) ClearUser() {
	m.cleareduser = true
	m.clearedFields[payment.FieldUserID] = struct{}{}
}

// UserCleared reports if the "user" edge to the User entity was cleared.
func (m *PaymentMutation) UserCleared() bool {
	return m.cleareduser
}

// UserIDs returns the "user" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UserID instead. It exists only for internal usage by the builders.
func (m *PaymentMutation) UserIDs() (ids []string) {
	if id := m.user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUser resets all changes to the "user" edge.
func (m *PaymentMutation) ResetUser() {
	m.user = nil
	m.cleareduser = false
}

// Where appends a list predicates to the PaymentMutation builder.
func (m *PaymentMutation) Where(ps ...predicate.Payment) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the PaymentMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *PaymentMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Payment, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *PaymentMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *PaymentMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Payment).
func (m *PaymentMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *PaymentMutation) Fields() []string {
	fields := make([]string, 0, 14)
	if m.created_at != nil {
		fields = append(fields, payment.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, payment.FieldUpdatedAt)
	}
	if m.out_trade_no != nil {
		fields = append(fields, payment.FieldOutTradeNo)
	}
	if m.user != nil {
		fields = append(fields, payment.FieldUserID)
	}
	if m.transaction_id != nil {
		fields = append(fields, payment.FieldTransactionID)
	}
	if m.open_id != nil {
		fields = append(fields, payment.FieldOpenID)
	}
	if m.channel != nil {
		fields = append(fields, payment.FieldChannel)
	}
	if m.platform != nil {
		fields = append(fields, payment.FieldPlatform)
	}
	if m.service != nil {
		fields = append(fields, payment.FieldService)
	}
	if m.amount != nil {
		fields = append(fields, payment.FieldAmount)
	}
	if m.currency != nil {
		fields = append(fields, payment.FieldCurrency)
	}
	if m.description != nil {
		fields = append(fields, payment.FieldDescription)
	}
	if m.status != nil {
		fields = append(fields, payment.FieldStatus)
	}
	if m.paid_at != nil {
		fields = append(fields, payment.FieldPaidAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *PaymentMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case payment.FieldCreatedAt:
		return m.CreatedAt()
	case payment.FieldUpdatedAt:
		return m.UpdatedAt()
	case payment.FieldOutTradeNo:
		return m.OutTradeNo()
	case payment.FieldUserID:
		return m.UserID()
	case payment.FieldTransactionID:
		return m.TransactionID()
	case payment.FieldOpenID:
		return m.OpenID()
	case payment.FieldChannel:
		return m.Channel()
	case payment.FieldPlatform:
		return m.Platform()
	case payment.FieldService:
		return m.Service()
	case payment.FieldAmount:
		return m.Amount()
	case payment.FieldCurrency:
		return m.Currency()
	case payment.FieldDescription:
		return m.Description()
	case payment.FieldStatus:
		return m.Status()
	case payment.FieldPaidAt:
		return m.PaidAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *PaymentMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case payment.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case payment.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case payment.FieldOutTradeNo:
		return m.OldOutTradeNo(ctx)
	case payment.FieldUserID:
		return m.OldUserID(ctx)
	case payment.FieldTransactionID:
		return m.OldTransactionID(ctx)
	case payment.FieldOpenID:
		return m.OldOpenID(ctx)
	case payment.FieldChannel:
		return m.OldChannel(ctx)
	case payment.FieldPlatform:
		return m.OldPlatform(ctx)
	case payment.FieldService:
		return m.OldService(ctx)
	case payment.FieldAmount:
		return m.OldAmount(ctx)
	case payment.FieldCurrency:
		return m.OldCurrency(ctx)
	case payment.FieldDescription:
		return m.OldDescription(ctx)
	case payment.FieldStatus:
		return m.OldStatus(ctx)
	case payment.FieldPaidAt:
		return m.OldPaidAt(ctx)
	}
	return nil, fmt.Errorf("unknown Payment field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PaymentMutation) SetField(name string, value ent.Value) error {
	switch name {
	case payment.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case payment.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case payment.FieldOutTradeNo:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOutTradeNo(v)
		return nil
	case payment.FieldUserID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserID(v)
		return nil
	case payment.FieldTransactionID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTransactionID(v)
		return nil
	case payment.FieldOpenID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOpenID(v)
		return nil
	case payment.FieldChannel:
		v, ok := value.(payment.Channel)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetChannel(v)
		return nil
	case payment.FieldPlatform:
		v, ok := value.(payment.Platform)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPlatform(v)
		return nil
	case payment.FieldService:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetService(v)
		return nil
	case payment.FieldAmount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAmount(v)
		return nil
	case payment.FieldCurrency:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCurrency(v)
		return nil
	case payment.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case payment.FieldStatus:
		v, ok := value.(payment.Status)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case payment.FieldPaidAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPaidAt(v)
		return nil
	}
	return fmt.Errorf("unknown Payment field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *PaymentMutation) AddedFields() []string {
	var fields []string
	if m.addamount != nil {
		fields = append(fields, payment.FieldAmount)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *PaymentMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case payment.FieldAmount:
		return m.AddedAmount()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PaymentMutation) AddField(name string, value ent.Value) error {
	switch name {
	case payment.FieldAmount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddAmount(v)
		return nil
	}
	return fmt.Errorf("unknown Payment numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *PaymentMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(payment.FieldTransactionID) {
		fields = append(fields, payment.FieldTransactionID)
	}
	if m.FieldCleared(payment.FieldOpenID) {
		fields = append(fields, payment.FieldOpenID)
	}
	if m.FieldCleared(payment.FieldPaidAt) {
		fields = append(fields, payment.FieldPaidAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *PaymentMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *PaymentMutation) ClearField(name string) error {
	switch name {
	case payment.FieldTransactionID:
		m.ClearTransactionID()
		return nil
	case payment.FieldOpenID:
		m.ClearOpenID()
		return nil
	case payment.FieldPaidAt:
		m.ClearPaidAt()
		return nil
	}
	return fmt.Errorf("unknown Payment nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *PaymentMutation) ResetField(name string) error {
	switch name {
	case payment.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case payment.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case payment.FieldOutTradeNo:
		m.ResetOutTradeNo()
		return nil
	case payment.FieldUserID:
		m.ResetUserID()
		return nil
	case payment.FieldTransactionID:
		m.ResetTransactionID()
		return nil
	case payment.FieldOpenID:
		m.ResetOpenID()
		return nil
	case payment.FieldChannel:
		m.ResetChannel()
		return nil
	case payment.FieldPlatform:
		m.ResetPlatform()
		return nil
	case payment.FieldService:
		m.ResetService()
		return nil
	case payment.FieldAmount:
		m.ResetAmount()
		return nil
	case payment.FieldCurrency:
		m.ResetCurrency()
		return nil
	case payment.FieldDescription:
		m.ResetDescription()
		return nil
	case payment.FieldStatus:
		m.ResetStatus()
		return nil
	case payment.FieldPaidAt:
		m.ResetPaidAt()
		return nil
	}
	return fmt.Errorf("unknown Payment field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *PaymentMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.user != nil {
		edges = append(edges, payment.EdgeUser)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *PaymentMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case payment.EdgeUser:
		if id := m.user; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *PaymentMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *PaymentMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *PaymentMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.cleareduser {
		edges = append(edges, payment.EdgeUser)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *PaymentMutation) EdgeCleared(name string) bool {
	switch name {
	case payment.EdgeUser:
		return m.cleareduser
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *PaymentMutation) ClearEdge(name string) error {
	switch name {
	case payment.EdgeUser:
		m.ClearUser()
		return nil
	}
	return fmt.Errorf("unknown Payment unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *PaymentMutation) ResetEdge(name string) error {
	switch name {
	case payment.EdgeUser:
		m.ResetUser()
		return nil
	}
	return fmt.Errorf("unknown Payment edge %s", name)
}

// QyWechatUserIDMutation represents an operation that mutates the QyWechatUserID nodes in the graph.
type QyWechatUserIDMutation struct {
	config
	op                Op
	typ               string
	id                *uuid.UUID
	created_at        *time.Time
	updated_at        *time.Time
	deleted_at        *time.Time
	qy_wechat_user_id *string
	open_id           *string
	clearedFields     map[string]struct{}
	user              *string
	cleareduser       bool
	done              bool
	oldValue          func(context.Context) (*QyWechatUserID, error)
	predicates        []predicate.QyWechatUserID
}

var _ ent.Mutation = (*QyWechatUserIDMutation)(nil)

// qywechatuseridOption allows management of the mutation configuration using functional options.
type qywechatuseridOption func(*QyWechatUserIDMutation)

// newQyWechatUserIDMutation creates new mutation for the QyWechatUserID entity.
func newQyWechatUserIDMutation(c config, op Op, opts ...qywechatuseridOption) *QyWechatUserIDMutation {
	m := &QyWechatUserIDMutation{
		config:        c,
		op:            op,
		typ:           TypeQyWechatUserID,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withQyWechatUserIDID sets the ID field of the mutation.
func withQyWechatUserIDID(id uuid.UUID) qywechatuseridOption {
	return func(m *QyWechatUserIDMutation) {
		var (
			err   error
			once  sync.Once
			value *QyWechatUserID
		)
		m.oldValue = func(ctx context.Context) (*QyWechatUserID, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().QyWechatUserID.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withQyWechatUserID sets the old QyWechatUserID of the mutation.
func withQyWechatUserID(node *QyWechatUserID) qywechatuseridOption {
	return func(m *QyWechatUserIDMutation) {
		m.oldValue = func(context.Context) (*QyWechatUserID, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m QyWechatUserIDMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m QyWechatUserIDMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of QyWechatUserID entities.
func (m *QyWechatUserIDMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *QyWechatUserIDMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *QyWechatUserIDMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().QyWechatUserID.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *QyWechatUserIDMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *QyWechatUserIDMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the QyWechatUserID entity.
// If the QyWechatUserID object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *QyWechatUserIDMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *QyWechatUserIDMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *QyWechatUserIDMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *QyWechatUserIDMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the QyWechatUserID entity.
// If the QyWechatUserID object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *QyWechatUserIDMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *QyWechatUserIDMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *QyWechatUserIDMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *QyWechatUserIDMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the QyWechatUserID entity.
// If the QyWechatUserID object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *QyWechatUserIDMutation) OldDeletedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *QyWechatUserIDMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[qywechatuserid.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *QyWechatUserIDMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[qywechatuserid.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *QyWechatUserIDMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, qywechatuserid.FieldDeletedAt)
}

// SetQyWechatUserID sets the "qy_wechat_user_id" field.
func (m *QyWechatUserIDMutation) SetQyWechatUserID(s string) {
	m.qy_wechat_user_id = &s
}

// QyWechatUserID returns the value of the "qy_wechat_user_id" field in the mutation.
func (m *QyWechatUserIDMutation) QyWechatUserID() (r string, exists bool) {
	v := m.qy_wechat_user_id
	if v == nil {
		return
	}
	return *v, true
}

// OldQyWechatUserID returns the old "qy_wechat_user_id" field's value of the QyWechatUserID entity.
// If the QyWechatUserID object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *QyWechatUserIDMutation) OldQyWechatUserID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldQyWechatUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldQyWechatUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldQyWechatUserID: %w", err)
	}
	return oldValue.QyWechatUserID, nil
}

// ClearQyWechatUserID clears the value of the "qy_wechat_user_id" field.
func (m *QyWechatUserIDMutation) ClearQyWechatUserID() {
	m.qy_wechat_user_id = nil
	m.clearedFields[qywechatuserid.FieldQyWechatUserID] = struct{}{}
}

// QyWechatUserIDCleared returns if the "qy_wechat_user_id" field was cleared in this mutation.
func (m *QyWechatUserIDMutation) QyWechatUserIDCleared() bool {
	_, ok := m.clearedFields[qywechatuserid.FieldQyWechatUserID]
	return ok
}

// ResetQyWechatUserID resets all changes to the "qy_wechat_user_id" field.
func (m *QyWechatUserIDMutation) ResetQyWechatUserID() {
	m.qy_wechat_user_id = nil
	delete(m.clearedFields, qywechatuserid.FieldQyWechatUserID)
}

// SetUserID sets the "user_id" field.
func (m *QyWechatUserIDMutation) SetUserID(s string) {
	m.user = &s
}

// UserID returns the value of the "user_id" field in the mutation.
func (m *QyWechatUserIDMutation) UserID() (r string, exists bool) {
	v := m.user
	if v == nil {
		return
	}
	return *v, true
}

// OldUserID returns the old "user_id" field's value of the QyWechatUserID entity.
// If the QyWechatUserID object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *QyWechatUserIDMutation) OldUserID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserID: %w", err)
	}
	return oldValue.UserID, nil
}

// ResetUserID resets all changes to the "user_id" field.
func (m *QyWechatUserIDMutation) ResetUserID() {
	m.user = nil
}

// SetOpenID sets the "open_id" field.
func (m *QyWechatUserIDMutation) SetOpenID(s string) {
	m.open_id = &s
}

// OpenID returns the value of the "open_id" field in the mutation.
func (m *QyWechatUserIDMutation) OpenID() (r string, exists bool) {
	v := m.open_id
	if v == nil {
		return
	}
	return *v, true
}

// OldOpenID returns the old "open_id" field's value of the QyWechatUserID entity.
// If the QyWechatUserID object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *QyWechatUserIDMutation) OldOpenID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOpenID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOpenID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOpenID: %w", err)
	}
	return oldValue.OpenID, nil
}

// ClearOpenID clears the value of the "open_id" field.
func (m *QyWechatUserIDMutation) ClearOpenID() {
	m.open_id = nil
	m.clearedFields[qywechatuserid.FieldOpenID] = struct{}{}
}

// OpenIDCleared returns if the "open_id" field was cleared in this mutation.
func (m *QyWechatUserIDMutation) OpenIDCleared() bool {
	_, ok := m.clearedFields[qywechatuserid.FieldOpenID]
	return ok
}

// ResetOpenID resets all changes to the "open_id" field.
func (m *QyWechatUserIDMutation) ResetOpenID() {
	m.open_id = nil
	delete(m.clearedFields, qywechatuserid.FieldOpenID)
}

// ClearUser clears the "user" edge to the User entity.
func (m *QyWechatUserIDMutation) ClearUser() {
	m.cleareduser = true
	m.clearedFields[qywechatuserid.FieldUserID] = struct{}{}
}

// UserCleared reports if the "user" edge to the User entity was cleared.
func (m *QyWechatUserIDMutation) UserCleared() bool {
	return m.cleareduser
}

// UserIDs returns the "user" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UserID instead. It exists only for internal usage by the builders.
func (m *QyWechatUserIDMutation) UserIDs() (ids []string) {
	if id := m.user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUser resets all changes to the "user" edge.
func (m *QyWechatUserIDMutation) ResetUser() {
	m.user = nil
	m.cleareduser = false
}

// Where appends a list predicates to the QyWechatUserIDMutation builder.
func (m *QyWechatUserIDMutation) Where(ps ...predicate.QyWechatUserID) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the QyWechatUserIDMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *QyWechatUserIDMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.QyWechatUserID, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *QyWechatUserIDMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *QyWechatUserIDMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (QyWechatUserID).
func (m *QyWechatUserIDMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *QyWechatUserIDMutation) Fields() []string {
	fields := make([]string, 0, 6)
	if m.created_at != nil {
		fields = append(fields, qywechatuserid.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, qywechatuserid.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, qywechatuserid.FieldDeletedAt)
	}
	if m.qy_wechat_user_id != nil {
		fields = append(fields, qywechatuserid.FieldQyWechatUserID)
	}
	if m.user != nil {
		fields = append(fields, qywechatuserid.FieldUserID)
	}
	if m.open_id != nil {
		fields = append(fields, qywechatuserid.FieldOpenID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *QyWechatUserIDMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case qywechatuserid.FieldCreatedAt:
		return m.CreatedAt()
	case qywechatuserid.FieldUpdatedAt:
		return m.UpdatedAt()
	case qywechatuserid.FieldDeletedAt:
		return m.DeletedAt()
	case qywechatuserid.FieldQyWechatUserID:
		return m.QyWechatUserID()
	case qywechatuserid.FieldUserID:
		return m.UserID()
	case qywechatuserid.FieldOpenID:
		return m.OpenID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *QyWechatUserIDMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case qywechatuserid.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case qywechatuserid.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case qywechatuserid.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case qywechatuserid.FieldQyWechatUserID:
		return m.OldQyWechatUserID(ctx)
	case qywechatuserid.FieldUserID:
		return m.OldUserID(ctx)
	case qywechatuserid.FieldOpenID:
		return m.OldOpenID(ctx)
	}
	return nil, fmt.Errorf("unknown QyWechatUserID field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *QyWechatUserIDMutation) SetField(name string, value ent.Value) error {
	switch name {
	case qywechatuserid.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case qywechatuserid.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case qywechatuserid.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case qywechatuserid.FieldQyWechatUserID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetQyWechatUserID(v)
		return nil
	case qywechatuserid.FieldUserID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserID(v)
		return nil
	case qywechatuserid.FieldOpenID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOpenID(v)
		return nil
	}
	return fmt.Errorf("unknown QyWechatUserID field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *QyWechatUserIDMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *QyWechatUserIDMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *QyWechatUserIDMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown QyWechatUserID numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *QyWechatUserIDMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(qywechatuserid.FieldDeletedAt) {
		fields = append(fields, qywechatuserid.FieldDeletedAt)
	}
	if m.FieldCleared(qywechatuserid.FieldQyWechatUserID) {
		fields = append(fields, qywechatuserid.FieldQyWechatUserID)
	}
	if m.FieldCleared(qywechatuserid.FieldOpenID) {
		fields = append(fields, qywechatuserid.FieldOpenID)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *QyWechatUserIDMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *QyWechatUserIDMutation) ClearField(name string) error {
	switch name {
	case qywechatuserid.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case qywechatuserid.FieldQyWechatUserID:
		m.ClearQyWechatUserID()
		return nil
	case qywechatuserid.FieldOpenID:
		m.ClearOpenID()
		return nil
	}
	return fmt.Errorf("unknown QyWechatUserID nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *QyWechatUserIDMutation) ResetField(name string) error {
	switch name {
	case qywechatuserid.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case qywechatuserid.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case qywechatuserid.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case qywechatuserid.FieldQyWechatUserID:
		m.ResetQyWechatUserID()
		return nil
	case qywechatuserid.FieldUserID:
		m.ResetUserID()
		return nil
	case qywechatuserid.FieldOpenID:
		m.ResetOpenID()
		return nil
	}
	return fmt.Errorf("unknown QyWechatUserID field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *QyWechatUserIDMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.user != nil {
		edges = append(edges, qywechatuserid.EdgeUser)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *QyWechatUserIDMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case qywechatuserid.EdgeUser:
		if id := m.user; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *QyWechatUserIDMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *QyWechatUserIDMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *QyWechatUserIDMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.cleareduser {
		edges = append(edges, qywechatuserid.EdgeUser)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *QyWechatUserIDMutation) EdgeCleared(name string) bool {
	switch name {
	case qywechatuserid.EdgeUser:
		return m.cleareduser
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *QyWechatUserIDMutation) ClearEdge(name string) error {
	switch name {
	case qywechatuserid.EdgeUser:
		m.ClearUser()
		return nil
	}
	return fmt.Errorf("unknown QyWechatUserID unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *QyWechatUserIDMutation) ResetEdge(name string) error {
	switch name {
	case qywechatuserid.EdgeUser:
		m.ResetUser()
		return nil
	}
	return fmt.Errorf("unknown QyWechatUserID edge %s", name)
}

// RoleMutation represents an operation that mutates the Role nodes in the graph.
type RoleMutation struct {
	config
	op                 Op
	typ                string
	id                 *uuid.UUID
	created_at         *time.Time
	updated_at         *time.Time
	deleted_at         *time.Time
	name               *string
	_type              *role.Type
	clearedFields      map[string]struct{}
	scopes             map[uuid.UUID]struct{}
	removedscopes      map[uuid.UUID]struct{}
	clearedscopes      bool
	application        *uuid.UUID
	clearedapplication bool
	done               bool
	oldValue           func(context.Context) (*Role, error)
	predicates         []predicate.Role
}

var _ ent.Mutation = (*RoleMutation)(nil)

// roleOption allows management of the mutation configuration using functional options.
type roleOption func(*RoleMutation)

// newRoleMutation creates new mutation for the Role entity.
func newRoleMutation(c config, op Op, opts ...roleOption) *RoleMutation {
	m := &RoleMutation{
		config:        c,
		op:            op,
		typ:           TypeRole,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withRoleID sets the ID field of the mutation.
func withRoleID(id uuid.UUID) roleOption {
	return func(m *RoleMutation) {
		var (
			err   error
			once  sync.Once
			value *Role
		)
		m.oldValue = func(ctx context.Context) (*Role, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Role.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withRole sets the old Role of the mutation.
func withRole(node *Role) roleOption {
	return func(m *RoleMutation) {
		m.oldValue = func(context.Context) (*Role, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m RoleMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m RoleMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Role entities.
func (m *RoleMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *RoleMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *RoleMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Role.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *RoleMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *RoleMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Role entity.
// If the Role object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RoleMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *RoleMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *RoleMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *RoleMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Role entity.
// If the Role object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RoleMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *RoleMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *RoleMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *RoleMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the Role entity.
// If the Role object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RoleMutation) OldDeletedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *RoleMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[role.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *RoleMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[role.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *RoleMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, role.FieldDeletedAt)
}

// SetApplicationID sets the "application_id" field.
func (m *RoleMutation) SetApplicationID(u uuid.UUID) {
	m.application = &u
}

// ApplicationID returns the value of the "application_id" field in the mutation.
func (m *RoleMutation) ApplicationID() (r uuid.UUID, exists bool) {
	v := m.application
	if v == nil {
		return
	}
	return *v, true
}

// OldApplicationID returns the old "application_id" field's value of the Role entity.
// If the Role object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RoleMutation) OldApplicationID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldApplicationID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldApplicationID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldApplicationID: %w", err)
	}
	return oldValue.ApplicationID, nil
}

// ResetApplicationID resets all changes to the "application_id" field.
func (m *RoleMutation) ResetApplicationID() {
	m.application = nil
}

// SetName sets the "name" field.
func (m *RoleMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *RoleMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Role entity.
// If the Role object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RoleMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *RoleMutation) ResetName() {
	m.name = nil
}

// SetType sets the "type" field.
func (m *RoleMutation) SetType(r role.Type) {
	m._type = &r
}

// GetType returns the value of the "type" field in the mutation.
func (m *RoleMutation) GetType() (r role.Type, exists bool) {
	v := m._type
	if v == nil {
		return
	}
	return *v, true
}

// OldType returns the old "type" field's value of the Role entity.
// If the Role object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RoleMutation) OldType(ctx context.Context) (v role.Type, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldType: %w", err)
	}
	return oldValue.Type, nil
}

// ResetType resets all changes to the "type" field.
func (m *RoleMutation) ResetType() {
	m._type = nil
}

// AddScopeIDs adds the "scopes" edge to the Scope entity by ids.
func (m *RoleMutation) AddScopeIDs(ids ...uuid.UUID) {
	if m.scopes == nil {
		m.scopes = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.scopes[ids[i]] = struct{}{}
	}
}

// ClearScopes clears the "scopes" edge to the Scope entity.
func (m *RoleMutation) ClearScopes() {
	m.clearedscopes = true
}

// ScopesCleared reports if the "scopes" edge to the Scope entity was cleared.
func (m *RoleMutation) ScopesCleared() bool {
	return m.clearedscopes
}

// RemoveScopeIDs removes the "scopes" edge to the Scope entity by IDs.
func (m *RoleMutation) RemoveScopeIDs(ids ...uuid.UUID) {
	if m.removedscopes == nil {
		m.removedscopes = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.scopes, ids[i])
		m.removedscopes[ids[i]] = struct{}{}
	}
}

// RemovedScopes returns the removed IDs of the "scopes" edge to the Scope entity.
func (m *RoleMutation) RemovedScopesIDs() (ids []uuid.UUID) {
	for id := range m.removedscopes {
		ids = append(ids, id)
	}
	return
}

// ScopesIDs returns the "scopes" edge IDs in the mutation.
func (m *RoleMutation) ScopesIDs() (ids []uuid.UUID) {
	for id := range m.scopes {
		ids = append(ids, id)
	}
	return
}

// ResetScopes resets all changes to the "scopes" edge.
func (m *RoleMutation) ResetScopes() {
	m.scopes = nil
	m.clearedscopes = false
	m.removedscopes = nil
}

// ClearApplication clears the "application" edge to the Application entity.
func (m *RoleMutation) ClearApplication() {
	m.clearedapplication = true
	m.clearedFields[role.FieldApplicationID] = struct{}{}
}

// ApplicationCleared reports if the "application" edge to the Application entity was cleared.
func (m *RoleMutation) ApplicationCleared() bool {
	return m.clearedapplication
}

// ApplicationIDs returns the "application" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ApplicationID instead. It exists only for internal usage by the builders.
func (m *RoleMutation) ApplicationIDs() (ids []uuid.UUID) {
	if id := m.application; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetApplication resets all changes to the "application" edge.
func (m *RoleMutation) ResetApplication() {
	m.application = nil
	m.clearedapplication = false
}

// Where appends a list predicates to the RoleMutation builder.
func (m *RoleMutation) Where(ps ...predicate.Role) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the RoleMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *RoleMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Role, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *RoleMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *RoleMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Role).
func (m *RoleMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *RoleMutation) Fields() []string {
	fields := make([]string, 0, 6)
	if m.created_at != nil {
		fields = append(fields, role.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, role.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, role.FieldDeletedAt)
	}
	if m.application != nil {
		fields = append(fields, role.FieldApplicationID)
	}
	if m.name != nil {
		fields = append(fields, role.FieldName)
	}
	if m._type != nil {
		fields = append(fields, role.FieldType)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *RoleMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case role.FieldCreatedAt:
		return m.CreatedAt()
	case role.FieldUpdatedAt:
		return m.UpdatedAt()
	case role.FieldDeletedAt:
		return m.DeletedAt()
	case role.FieldApplicationID:
		return m.ApplicationID()
	case role.FieldName:
		return m.Name()
	case role.FieldType:
		return m.GetType()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *RoleMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case role.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case role.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case role.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case role.FieldApplicationID:
		return m.OldApplicationID(ctx)
	case role.FieldName:
		return m.OldName(ctx)
	case role.FieldType:
		return m.OldType(ctx)
	}
	return nil, fmt.Errorf("unknown Role field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *RoleMutation) SetField(name string, value ent.Value) error {
	switch name {
	case role.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case role.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case role.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case role.FieldApplicationID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetApplicationID(v)
		return nil
	case role.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case role.FieldType:
		v, ok := value.(role.Type)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetType(v)
		return nil
	}
	return fmt.Errorf("unknown Role field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *RoleMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *RoleMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *RoleMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Role numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *RoleMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(role.FieldDeletedAt) {
		fields = append(fields, role.FieldDeletedAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *RoleMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *RoleMutation) ClearField(name string) error {
	switch name {
	case role.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	}
	return fmt.Errorf("unknown Role nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *RoleMutation) ResetField(name string) error {
	switch name {
	case role.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case role.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case role.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case role.FieldApplicationID:
		m.ResetApplicationID()
		return nil
	case role.FieldName:
		m.ResetName()
		return nil
	case role.FieldType:
		m.ResetType()
		return nil
	}
	return fmt.Errorf("unknown Role field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *RoleMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.scopes != nil {
		edges = append(edges, role.EdgeScopes)
	}
	if m.application != nil {
		edges = append(edges, role.EdgeApplication)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *RoleMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case role.EdgeScopes:
		ids := make([]ent.Value, 0, len(m.scopes))
		for id := range m.scopes {
			ids = append(ids, id)
		}
		return ids
	case role.EdgeApplication:
		if id := m.application; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *RoleMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removedscopes != nil {
		edges = append(edges, role.EdgeScopes)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *RoleMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case role.EdgeScopes:
		ids := make([]ent.Value, 0, len(m.removedscopes))
		for id := range m.removedscopes {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *RoleMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedscopes {
		edges = append(edges, role.EdgeScopes)
	}
	if m.clearedapplication {
		edges = append(edges, role.EdgeApplication)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *RoleMutation) EdgeCleared(name string) bool {
	switch name {
	case role.EdgeScopes:
		return m.clearedscopes
	case role.EdgeApplication:
		return m.clearedapplication
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *RoleMutation) ClearEdge(name string) error {
	switch name {
	case role.EdgeApplication:
		m.ClearApplication()
		return nil
	}
	return fmt.Errorf("unknown Role unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *RoleMutation) ResetEdge(name string) error {
	switch name {
	case role.EdgeScopes:
		m.ResetScopes()
		return nil
	case role.EdgeApplication:
		m.ResetApplication()
		return nil
	}
	return fmt.Errorf("unknown Role edge %s", name)
}

// ScopeMutation represents an operation that mutates the Scope nodes in the graph.
type ScopeMutation struct {
	config
	op            Op
	typ           string
	id            *uuid.UUID
	created_at    *time.Time
	updated_at    *time.Time
	deleted_at    *time.Time
	name          *string
	hidden_in_jwt *bool
	clearedFields map[string]struct{}
	role          *uuid.UUID
	clearedrole   bool
	done          bool
	oldValue      func(context.Context) (*Scope, error)
	predicates    []predicate.Scope
}

var _ ent.Mutation = (*ScopeMutation)(nil)

// scopeOption allows management of the mutation configuration using functional options.
type scopeOption func(*ScopeMutation)

// newScopeMutation creates new mutation for the Scope entity.
func newScopeMutation(c config, op Op, opts ...scopeOption) *ScopeMutation {
	m := &ScopeMutation{
		config:        c,
		op:            op,
		typ:           TypeScope,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withScopeID sets the ID field of the mutation.
func withScopeID(id uuid.UUID) scopeOption {
	return func(m *ScopeMutation) {
		var (
			err   error
			once  sync.Once
			value *Scope
		)
		m.oldValue = func(ctx context.Context) (*Scope, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Scope.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withScope sets the old Scope of the mutation.
func withScope(node *Scope) scopeOption {
	return func(m *ScopeMutation) {
		m.oldValue = func(context.Context) (*Scope, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ScopeMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ScopeMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Scope entities.
func (m *ScopeMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ScopeMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ScopeMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Scope.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *ScopeMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *ScopeMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Scope entity.
// If the Scope object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ScopeMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *ScopeMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *ScopeMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *ScopeMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Scope entity.
// If the Scope object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ScopeMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *ScopeMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *ScopeMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *ScopeMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the Scope entity.
// If the Scope object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ScopeMutation) OldDeletedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *ScopeMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[scope.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *ScopeMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[scope.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *ScopeMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, scope.FieldDeletedAt)
}

// SetRoleID sets the "role_id" field.
func (m *ScopeMutation) SetRoleID(u uuid.UUID) {
	m.role = &u
}

// RoleID returns the value of the "role_id" field in the mutation.
func (m *ScopeMutation) RoleID() (r uuid.UUID, exists bool) {
	v := m.role
	if v == nil {
		return
	}
	return *v, true
}

// OldRoleID returns the old "role_id" field's value of the Scope entity.
// If the Scope object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ScopeMutation) OldRoleID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRoleID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRoleID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRoleID: %w", err)
	}
	return oldValue.RoleID, nil
}

// ResetRoleID resets all changes to the "role_id" field.
func (m *ScopeMutation) ResetRoleID() {
	m.role = nil
}

// SetName sets the "name" field.
func (m *ScopeMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *ScopeMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Scope entity.
// If the Scope object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ScopeMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *ScopeMutation) ResetName() {
	m.name = nil
}

// SetHiddenInJwt sets the "hidden_in_jwt" field.
func (m *ScopeMutation) SetHiddenInJwt(b bool) {
	m.hidden_in_jwt = &b
}

// HiddenInJwt returns the value of the "hidden_in_jwt" field in the mutation.
func (m *ScopeMutation) HiddenInJwt() (r bool, exists bool) {
	v := m.hidden_in_jwt
	if v == nil {
		return
	}
	return *v, true
}

// OldHiddenInJwt returns the old "hidden_in_jwt" field's value of the Scope entity.
// If the Scope object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ScopeMutation) OldHiddenInJwt(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldHiddenInJwt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldHiddenInJwt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHiddenInJwt: %w", err)
	}
	return oldValue.HiddenInJwt, nil
}

// ResetHiddenInJwt resets all changes to the "hidden_in_jwt" field.
func (m *ScopeMutation) ResetHiddenInJwt() {
	m.hidden_in_jwt = nil
}

// ClearRole clears the "role" edge to the Role entity.
func (m *ScopeMutation) ClearRole() {
	m.clearedrole = true
	m.clearedFields[scope.FieldRoleID] = struct{}{}
}

// RoleCleared reports if the "role" edge to the Role entity was cleared.
func (m *ScopeMutation) RoleCleared() bool {
	return m.clearedrole
}

// RoleIDs returns the "role" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// RoleID instead. It exists only for internal usage by the builders.
func (m *ScopeMutation) RoleIDs() (ids []uuid.UUID) {
	if id := m.role; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetRole resets all changes to the "role" edge.
func (m *ScopeMutation) ResetRole() {
	m.role = nil
	m.clearedrole = false
}

// Where appends a list predicates to the ScopeMutation builder.
func (m *ScopeMutation) Where(ps ...predicate.Scope) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ScopeMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ScopeMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Scope, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ScopeMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ScopeMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Scope).
func (m *ScopeMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ScopeMutation) Fields() []string {
	fields := make([]string, 0, 6)
	if m.created_at != nil {
		fields = append(fields, scope.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, scope.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, scope.FieldDeletedAt)
	}
	if m.role != nil {
		fields = append(fields, scope.FieldRoleID)
	}
	if m.name != nil {
		fields = append(fields, scope.FieldName)
	}
	if m.hidden_in_jwt != nil {
		fields = append(fields, scope.FieldHiddenInJwt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ScopeMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case scope.FieldCreatedAt:
		return m.CreatedAt()
	case scope.FieldUpdatedAt:
		return m.UpdatedAt()
	case scope.FieldDeletedAt:
		return m.DeletedAt()
	case scope.FieldRoleID:
		return m.RoleID()
	case scope.FieldName:
		return m.Name()
	case scope.FieldHiddenInJwt:
		return m.HiddenInJwt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ScopeMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case scope.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case scope.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case scope.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case scope.FieldRoleID:
		return m.OldRoleID(ctx)
	case scope.FieldName:
		return m.OldName(ctx)
	case scope.FieldHiddenInJwt:
		return m.OldHiddenInJwt(ctx)
	}
	return nil, fmt.Errorf("unknown Scope field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ScopeMutation) SetField(name string, value ent.Value) error {
	switch name {
	case scope.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case scope.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case scope.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case scope.FieldRoleID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRoleID(v)
		return nil
	case scope.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case scope.FieldHiddenInJwt:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHiddenInJwt(v)
		return nil
	}
	return fmt.Errorf("unknown Scope field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ScopeMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ScopeMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ScopeMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Scope numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ScopeMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(scope.FieldDeletedAt) {
		fields = append(fields, scope.FieldDeletedAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ScopeMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ScopeMutation) ClearField(name string) error {
	switch name {
	case scope.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	}
	return fmt.Errorf("unknown Scope nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ScopeMutation) ResetField(name string) error {
	switch name {
	case scope.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case scope.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case scope.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case scope.FieldRoleID:
		m.ResetRoleID()
		return nil
	case scope.FieldName:
		m.ResetName()
		return nil
	case scope.FieldHiddenInJwt:
		m.ResetHiddenInJwt()
		return nil
	}
	return fmt.Errorf("unknown Scope field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ScopeMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.role != nil {
		edges = append(edges, scope.EdgeRole)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ScopeMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case scope.EdgeRole:
		if id := m.role; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ScopeMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ScopeMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ScopeMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedrole {
		edges = append(edges, scope.EdgeRole)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ScopeMutation) EdgeCleared(name string) bool {
	switch name {
	case scope.EdgeRole:
		return m.clearedrole
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ScopeMutation) ClearEdge(name string) error {
	switch name {
	case scope.EdgeRole:
		m.ClearRole()
		return nil
	}
	return fmt.Errorf("unknown Scope unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ScopeMutation) ResetEdge(name string) error {
	switch name {
	case scope.EdgeRole:
		m.ResetRole()
		return nil
	}
	return fmt.Errorf("unknown Scope edge %s", name)
}

// UserMutation represents an operation that mutates the User nodes in the graph.
type UserMutation struct {
	config
	op                        Op
	typ                       string
	id                        *string
	created_at                *time.Time
	updated_at                *time.Time
	deleted_at                *time.Time
	name                      *string
	display_name              *string
	avatar                    *string
	referral_channel          *entity.UserRefferalChannel
	department                *string
	clearedFields             map[string]struct{}
	bindings                  map[uuid.UUID]struct{}
	removedbindings           map[uuid.UUID]struct{}
	clearedbindings           bool
	devices                   map[int64]struct{}
	removeddevices            map[int64]struct{}
	cleareddevices            bool
	personal_role             *uuid.UUID
	clearedpersonal_role      bool
	open_ids                  map[uuid.UUID]struct{}
	removedopen_ids           map[uuid.UUID]struct{}
	clearedopen_ids           bool
	qy_wechat_user_ids        map[uuid.UUID]struct{}
	removedqy_wechat_user_ids map[uuid.UUID]struct{}
	clearedqy_wechat_user_ids bool
	payments                  map[int]struct{}
	removedpayments           map[int]struct{}
	clearedpayments           bool
	application               *uuid.UUID
	clearedapplication        bool
	organization_users        map[uuid.UUID]struct{}
	removedorganization_users map[uuid.UUID]struct{}
	clearedorganization_users bool
	done                      bool
	oldValue                  func(context.Context) (*User, error)
	predicates                []predicate.User
}

var _ ent.Mutation = (*UserMutation)(nil)

// userOption allows management of the mutation configuration using functional options.
type userOption func(*UserMutation)

// newUserMutation creates new mutation for the User entity.
func newUserMutation(c config, op Op, opts ...userOption) *UserMutation {
	m := &UserMutation{
		config:        c,
		op:            op,
		typ:           TypeUser,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withUserID sets the ID field of the mutation.
func withUserID(id string) userOption {
	return func(m *UserMutation) {
		var (
			err   error
			once  sync.Once
			value *User
		)
		m.oldValue = func(ctx context.Context) (*User, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().User.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withUser sets the old User of the mutation.
func withUser(node *User) userOption {
	return func(m *UserMutation) {
		m.oldValue = func(context.Context) (*User, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m UserMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m UserMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of User entities.
func (m *UserMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *UserMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *UserMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().User.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *UserMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *UserMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *UserMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *UserMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *UserMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *UserMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *UserMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *UserMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldDeletedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *UserMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[user.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *UserMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[user.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *UserMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, user.FieldDeletedAt)
}

// SetApplicationID sets the "application_id" field.
func (m *UserMutation) SetApplicationID(u uuid.UUID) {
	m.application = &u
}

// ApplicationID returns the value of the "application_id" field in the mutation.
func (m *UserMutation) ApplicationID() (r uuid.UUID, exists bool) {
	v := m.application
	if v == nil {
		return
	}
	return *v, true
}

// OldApplicationID returns the old "application_id" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldApplicationID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldApplicationID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldApplicationID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldApplicationID: %w", err)
	}
	return oldValue.ApplicationID, nil
}

// ResetApplicationID resets all changes to the "application_id" field.
func (m *UserMutation) ResetApplicationID() {
	m.application = nil
}

// SetName sets the "name" field.
func (m *UserMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *UserMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *UserMutation) ResetName() {
	m.name = nil
}

// SetDisplayName sets the "display_name" field.
func (m *UserMutation) SetDisplayName(s string) {
	m.display_name = &s
}

// DisplayName returns the value of the "display_name" field in the mutation.
func (m *UserMutation) DisplayName() (r string, exists bool) {
	v := m.display_name
	if v == nil {
		return
	}
	return *v, true
}

// OldDisplayName returns the old "display_name" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldDisplayName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDisplayName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDisplayName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDisplayName: %w", err)
	}
	return oldValue.DisplayName, nil
}

// ClearDisplayName clears the value of the "display_name" field.
func (m *UserMutation) ClearDisplayName() {
	m.display_name = nil
	m.clearedFields[user.FieldDisplayName] = struct{}{}
}

// DisplayNameCleared returns if the "display_name" field was cleared in this mutation.
func (m *UserMutation) DisplayNameCleared() bool {
	_, ok := m.clearedFields[user.FieldDisplayName]
	return ok
}

// ResetDisplayName resets all changes to the "display_name" field.
func (m *UserMutation) ResetDisplayName() {
	m.display_name = nil
	delete(m.clearedFields, user.FieldDisplayName)
}

// SetAvatar sets the "avatar" field.
func (m *UserMutation) SetAvatar(s string) {
	m.avatar = &s
}

// Avatar returns the value of the "avatar" field in the mutation.
func (m *UserMutation) Avatar() (r string, exists bool) {
	v := m.avatar
	if v == nil {
		return
	}
	return *v, true
}

// OldAvatar returns the old "avatar" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldAvatar(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAvatar is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAvatar requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAvatar: %w", err)
	}
	return oldValue.Avatar, nil
}

// ClearAvatar clears the value of the "avatar" field.
func (m *UserMutation) ClearAvatar() {
	m.avatar = nil
	m.clearedFields[user.FieldAvatar] = struct{}{}
}

// AvatarCleared returns if the "avatar" field was cleared in this mutation.
func (m *UserMutation) AvatarCleared() bool {
	_, ok := m.clearedFields[user.FieldAvatar]
	return ok
}

// ResetAvatar resets all changes to the "avatar" field.
func (m *UserMutation) ResetAvatar() {
	m.avatar = nil
	delete(m.clearedFields, user.FieldAvatar)
}

// SetReferralChannel sets the "referral_channel" field.
func (m *UserMutation) SetReferralChannel(erc entity.UserRefferalChannel) {
	m.referral_channel = &erc
}

// ReferralChannel returns the value of the "referral_channel" field in the mutation.
func (m *UserMutation) ReferralChannel() (r entity.UserRefferalChannel, exists bool) {
	v := m.referral_channel
	if v == nil {
		return
	}
	return *v, true
}

// OldReferralChannel returns the old "referral_channel" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldReferralChannel(ctx context.Context) (v entity.UserRefferalChannel, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldReferralChannel is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldReferralChannel requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldReferralChannel: %w", err)
	}
	return oldValue.ReferralChannel, nil
}

// ClearReferralChannel clears the value of the "referral_channel" field.
func (m *UserMutation) ClearReferralChannel() {
	m.referral_channel = nil
	m.clearedFields[user.FieldReferralChannel] = struct{}{}
}

// ReferralChannelCleared returns if the "referral_channel" field was cleared in this mutation.
func (m *UserMutation) ReferralChannelCleared() bool {
	_, ok := m.clearedFields[user.FieldReferralChannel]
	return ok
}

// ResetReferralChannel resets all changes to the "referral_channel" field.
func (m *UserMutation) ResetReferralChannel() {
	m.referral_channel = nil
	delete(m.clearedFields, user.FieldReferralChannel)
}

// SetDepartment sets the "department" field.
func (m *UserMutation) SetDepartment(s string) {
	m.department = &s
}

// Department returns the value of the "department" field in the mutation.
func (m *UserMutation) Department() (r string, exists bool) {
	v := m.department
	if v == nil {
		return
	}
	return *v, true
}

// OldDepartment returns the old "department" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldDepartment(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDepartment is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDepartment requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDepartment: %w", err)
	}
	return oldValue.Department, nil
}

// ClearDepartment clears the value of the "department" field.
func (m *UserMutation) ClearDepartment() {
	m.department = nil
	m.clearedFields[user.FieldDepartment] = struct{}{}
}

// DepartmentCleared returns if the "department" field was cleared in this mutation.
func (m *UserMutation) DepartmentCleared() bool {
	_, ok := m.clearedFields[user.FieldDepartment]
	return ok
}

// ResetDepartment resets all changes to the "department" field.
func (m *UserMutation) ResetDepartment() {
	m.department = nil
	delete(m.clearedFields, user.FieldDepartment)
}

// AddBindingIDs adds the "bindings" edge to the Binding entity by ids.
func (m *UserMutation) AddBindingIDs(ids ...uuid.UUID) {
	if m.bindings == nil {
		m.bindings = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.bindings[ids[i]] = struct{}{}
	}
}

// ClearBindings clears the "bindings" edge to the Binding entity.
func (m *UserMutation) ClearBindings() {
	m.clearedbindings = true
}

// BindingsCleared reports if the "bindings" edge to the Binding entity was cleared.
func (m *UserMutation) BindingsCleared() bool {
	return m.clearedbindings
}

// RemoveBindingIDs removes the "bindings" edge to the Binding entity by IDs.
func (m *UserMutation) RemoveBindingIDs(ids ...uuid.UUID) {
	if m.removedbindings == nil {
		m.removedbindings = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.bindings, ids[i])
		m.removedbindings[ids[i]] = struct{}{}
	}
}

// RemovedBindings returns the removed IDs of the "bindings" edge to the Binding entity.
func (m *UserMutation) RemovedBindingsIDs() (ids []uuid.UUID) {
	for id := range m.removedbindings {
		ids = append(ids, id)
	}
	return
}

// BindingsIDs returns the "bindings" edge IDs in the mutation.
func (m *UserMutation) BindingsIDs() (ids []uuid.UUID) {
	for id := range m.bindings {
		ids = append(ids, id)
	}
	return
}

// ResetBindings resets all changes to the "bindings" edge.
func (m *UserMutation) ResetBindings() {
	m.bindings = nil
	m.clearedbindings = false
	m.removedbindings = nil
}

// AddDeviceIDs adds the "devices" edge to the Device entity by ids.
func (m *UserMutation) AddDeviceIDs(ids ...int64) {
	if m.devices == nil {
		m.devices = make(map[int64]struct{})
	}
	for i := range ids {
		m.devices[ids[i]] = struct{}{}
	}
}

// ClearDevices clears the "devices" edge to the Device entity.
func (m *UserMutation) ClearDevices() {
	m.cleareddevices = true
}

// DevicesCleared reports if the "devices" edge to the Device entity was cleared.
func (m *UserMutation) DevicesCleared() bool {
	return m.cleareddevices
}

// RemoveDeviceIDs removes the "devices" edge to the Device entity by IDs.
func (m *UserMutation) RemoveDeviceIDs(ids ...int64) {
	if m.removeddevices == nil {
		m.removeddevices = make(map[int64]struct{})
	}
	for i := range ids {
		delete(m.devices, ids[i])
		m.removeddevices[ids[i]] = struct{}{}
	}
}

// RemovedDevices returns the removed IDs of the "devices" edge to the Device entity.
func (m *UserMutation) RemovedDevicesIDs() (ids []int64) {
	for id := range m.removeddevices {
		ids = append(ids, id)
	}
	return
}

// DevicesIDs returns the "devices" edge IDs in the mutation.
func (m *UserMutation) DevicesIDs() (ids []int64) {
	for id := range m.devices {
		ids = append(ids, id)
	}
	return
}

// ResetDevices resets all changes to the "devices" edge.
func (m *UserMutation) ResetDevices() {
	m.devices = nil
	m.cleareddevices = false
	m.removeddevices = nil
}

// SetPersonalRoleID sets the "personal_role" edge to the Role entity by id.
func (m *UserMutation) SetPersonalRoleID(id uuid.UUID) {
	m.personal_role = &id
}

// ClearPersonalRole clears the "personal_role" edge to the Role entity.
func (m *UserMutation) ClearPersonalRole() {
	m.clearedpersonal_role = true
}

// PersonalRoleCleared reports if the "personal_role" edge to the Role entity was cleared.
func (m *UserMutation) PersonalRoleCleared() bool {
	return m.clearedpersonal_role
}

// PersonalRoleID returns the "personal_role" edge ID in the mutation.
func (m *UserMutation) PersonalRoleID() (id uuid.UUID, exists bool) {
	if m.personal_role != nil {
		return *m.personal_role, true
	}
	return
}

// PersonalRoleIDs returns the "personal_role" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// PersonalRoleID instead. It exists only for internal usage by the builders.
func (m *UserMutation) PersonalRoleIDs() (ids []uuid.UUID) {
	if id := m.personal_role; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetPersonalRole resets all changes to the "personal_role" edge.
func (m *UserMutation) ResetPersonalRole() {
	m.personal_role = nil
	m.clearedpersonal_role = false
}

// AddOpenIDIDs adds the "open_ids" edge to the WechatOpenID entity by ids.
func (m *UserMutation) AddOpenIDIDs(ids ...uuid.UUID) {
	if m.open_ids == nil {
		m.open_ids = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.open_ids[ids[i]] = struct{}{}
	}
}

// ClearOpenIds clears the "open_ids" edge to the WechatOpenID entity.
func (m *UserMutation) ClearOpenIds() {
	m.clearedopen_ids = true
}

// OpenIdsCleared reports if the "open_ids" edge to the WechatOpenID entity was cleared.
func (m *UserMutation) OpenIdsCleared() bool {
	return m.clearedopen_ids
}

// RemoveOpenIDIDs removes the "open_ids" edge to the WechatOpenID entity by IDs.
func (m *UserMutation) RemoveOpenIDIDs(ids ...uuid.UUID) {
	if m.removedopen_ids == nil {
		m.removedopen_ids = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.open_ids, ids[i])
		m.removedopen_ids[ids[i]] = struct{}{}
	}
}

// RemovedOpenIds returns the removed IDs of the "open_ids" edge to the WechatOpenID entity.
func (m *UserMutation) RemovedOpenIdsIDs() (ids []uuid.UUID) {
	for id := range m.removedopen_ids {
		ids = append(ids, id)
	}
	return
}

// OpenIdsIDs returns the "open_ids" edge IDs in the mutation.
func (m *UserMutation) OpenIdsIDs() (ids []uuid.UUID) {
	for id := range m.open_ids {
		ids = append(ids, id)
	}
	return
}

// ResetOpenIds resets all changes to the "open_ids" edge.
func (m *UserMutation) ResetOpenIds() {
	m.open_ids = nil
	m.clearedopen_ids = false
	m.removedopen_ids = nil
}

// AddQyWechatUserIDIDs adds the "qy_wechat_user_ids" edge to the QyWechatUserID entity by ids.
func (m *UserMutation) AddQyWechatUserIDIDs(ids ...uuid.UUID) {
	if m.qy_wechat_user_ids == nil {
		m.qy_wechat_user_ids = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.qy_wechat_user_ids[ids[i]] = struct{}{}
	}
}

// ClearQyWechatUserIds clears the "qy_wechat_user_ids" edge to the QyWechatUserID entity.
func (m *UserMutation) ClearQyWechatUserIds() {
	m.clearedqy_wechat_user_ids = true
}

// QyWechatUserIdsCleared reports if the "qy_wechat_user_ids" edge to the QyWechatUserID entity was cleared.
func (m *UserMutation) QyWechatUserIdsCleared() bool {
	return m.clearedqy_wechat_user_ids
}

// RemoveQyWechatUserIDIDs removes the "qy_wechat_user_ids" edge to the QyWechatUserID entity by IDs.
func (m *UserMutation) RemoveQyWechatUserIDIDs(ids ...uuid.UUID) {
	if m.removedqy_wechat_user_ids == nil {
		m.removedqy_wechat_user_ids = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.qy_wechat_user_ids, ids[i])
		m.removedqy_wechat_user_ids[ids[i]] = struct{}{}
	}
}

// RemovedQyWechatUserIds returns the removed IDs of the "qy_wechat_user_ids" edge to the QyWechatUserID entity.
func (m *UserMutation) RemovedQyWechatUserIdsIDs() (ids []uuid.UUID) {
	for id := range m.removedqy_wechat_user_ids {
		ids = append(ids, id)
	}
	return
}

// QyWechatUserIdsIDs returns the "qy_wechat_user_ids" edge IDs in the mutation.
func (m *UserMutation) QyWechatUserIdsIDs() (ids []uuid.UUID) {
	for id := range m.qy_wechat_user_ids {
		ids = append(ids, id)
	}
	return
}

// ResetQyWechatUserIds resets all changes to the "qy_wechat_user_ids" edge.
func (m *UserMutation) ResetQyWechatUserIds() {
	m.qy_wechat_user_ids = nil
	m.clearedqy_wechat_user_ids = false
	m.removedqy_wechat_user_ids = nil
}

// AddPaymentIDs adds the "payments" edge to the Payment entity by ids.
func (m *UserMutation) AddPaymentIDs(ids ...int) {
	if m.payments == nil {
		m.payments = make(map[int]struct{})
	}
	for i := range ids {
		m.payments[ids[i]] = struct{}{}
	}
}

// ClearPayments clears the "payments" edge to the Payment entity.
func (m *UserMutation) ClearPayments() {
	m.clearedpayments = true
}

// PaymentsCleared reports if the "payments" edge to the Payment entity was cleared.
func (m *UserMutation) PaymentsCleared() bool {
	return m.clearedpayments
}

// RemovePaymentIDs removes the "payments" edge to the Payment entity by IDs.
func (m *UserMutation) RemovePaymentIDs(ids ...int) {
	if m.removedpayments == nil {
		m.removedpayments = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.payments, ids[i])
		m.removedpayments[ids[i]] = struct{}{}
	}
}

// RemovedPayments returns the removed IDs of the "payments" edge to the Payment entity.
func (m *UserMutation) RemovedPaymentsIDs() (ids []int) {
	for id := range m.removedpayments {
		ids = append(ids, id)
	}
	return
}

// PaymentsIDs returns the "payments" edge IDs in the mutation.
func (m *UserMutation) PaymentsIDs() (ids []int) {
	for id := range m.payments {
		ids = append(ids, id)
	}
	return
}

// ResetPayments resets all changes to the "payments" edge.
func (m *UserMutation) ResetPayments() {
	m.payments = nil
	m.clearedpayments = false
	m.removedpayments = nil
}

// ClearApplication clears the "application" edge to the Application entity.
func (m *UserMutation) ClearApplication() {
	m.clearedapplication = true
	m.clearedFields[user.FieldApplicationID] = struct{}{}
}

// ApplicationCleared reports if the "application" edge to the Application entity was cleared.
func (m *UserMutation) ApplicationCleared() bool {
	return m.clearedapplication
}

// ApplicationIDs returns the "application" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ApplicationID instead. It exists only for internal usage by the builders.
func (m *UserMutation) ApplicationIDs() (ids []uuid.UUID) {
	if id := m.application; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetApplication resets all changes to the "application" edge.
func (m *UserMutation) ResetApplication() {
	m.application = nil
	m.clearedapplication = false
}

// AddOrganizationUserIDs adds the "organization_users" edge to the OrganizationUser entity by ids.
func (m *UserMutation) AddOrganizationUserIDs(ids ...uuid.UUID) {
	if m.organization_users == nil {
		m.organization_users = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.organization_users[ids[i]] = struct{}{}
	}
}

// ClearOrganizationUsers clears the "organization_users" edge to the OrganizationUser entity.
func (m *UserMutation) ClearOrganizationUsers() {
	m.clearedorganization_users = true
}

// OrganizationUsersCleared reports if the "organization_users" edge to the OrganizationUser entity was cleared.
func (m *UserMutation) OrganizationUsersCleared() bool {
	return m.clearedorganization_users
}

// RemoveOrganizationUserIDs removes the "organization_users" edge to the OrganizationUser entity by IDs.
func (m *UserMutation) RemoveOrganizationUserIDs(ids ...uuid.UUID) {
	if m.removedorganization_users == nil {
		m.removedorganization_users = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.organization_users, ids[i])
		m.removedorganization_users[ids[i]] = struct{}{}
	}
}

// RemovedOrganizationUsers returns the removed IDs of the "organization_users" edge to the OrganizationUser entity.
func (m *UserMutation) RemovedOrganizationUsersIDs() (ids []uuid.UUID) {
	for id := range m.removedorganization_users {
		ids = append(ids, id)
	}
	return
}

// OrganizationUsersIDs returns the "organization_users" edge IDs in the mutation.
func (m *UserMutation) OrganizationUsersIDs() (ids []uuid.UUID) {
	for id := range m.organization_users {
		ids = append(ids, id)
	}
	return
}

// ResetOrganizationUsers resets all changes to the "organization_users" edge.
func (m *UserMutation) ResetOrganizationUsers() {
	m.organization_users = nil
	m.clearedorganization_users = false
	m.removedorganization_users = nil
}

// Where appends a list predicates to the UserMutation builder.
func (m *UserMutation) Where(ps ...predicate.User) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the UserMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *UserMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.User, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *UserMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *UserMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (User).
func (m *UserMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *UserMutation) Fields() []string {
	fields := make([]string, 0, 9)
	if m.created_at != nil {
		fields = append(fields, user.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, user.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, user.FieldDeletedAt)
	}
	if m.application != nil {
		fields = append(fields, user.FieldApplicationID)
	}
	if m.name != nil {
		fields = append(fields, user.FieldName)
	}
	if m.display_name != nil {
		fields = append(fields, user.FieldDisplayName)
	}
	if m.avatar != nil {
		fields = append(fields, user.FieldAvatar)
	}
	if m.referral_channel != nil {
		fields = append(fields, user.FieldReferralChannel)
	}
	if m.department != nil {
		fields = append(fields, user.FieldDepartment)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *UserMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case user.FieldCreatedAt:
		return m.CreatedAt()
	case user.FieldUpdatedAt:
		return m.UpdatedAt()
	case user.FieldDeletedAt:
		return m.DeletedAt()
	case user.FieldApplicationID:
		return m.ApplicationID()
	case user.FieldName:
		return m.Name()
	case user.FieldDisplayName:
		return m.DisplayName()
	case user.FieldAvatar:
		return m.Avatar()
	case user.FieldReferralChannel:
		return m.ReferralChannel()
	case user.FieldDepartment:
		return m.Department()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *UserMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case user.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case user.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case user.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case user.FieldApplicationID:
		return m.OldApplicationID(ctx)
	case user.FieldName:
		return m.OldName(ctx)
	case user.FieldDisplayName:
		return m.OldDisplayName(ctx)
	case user.FieldAvatar:
		return m.OldAvatar(ctx)
	case user.FieldReferralChannel:
		return m.OldReferralChannel(ctx)
	case user.FieldDepartment:
		return m.OldDepartment(ctx)
	}
	return nil, fmt.Errorf("unknown User field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserMutation) SetField(name string, value ent.Value) error {
	switch name {
	case user.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case user.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case user.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case user.FieldApplicationID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetApplicationID(v)
		return nil
	case user.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case user.FieldDisplayName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDisplayName(v)
		return nil
	case user.FieldAvatar:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAvatar(v)
		return nil
	case user.FieldReferralChannel:
		v, ok := value.(entity.UserRefferalChannel)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetReferralChannel(v)
		return nil
	case user.FieldDepartment:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDepartment(v)
		return nil
	}
	return fmt.Errorf("unknown User field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *UserMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *UserMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown User numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *UserMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(user.FieldDeletedAt) {
		fields = append(fields, user.FieldDeletedAt)
	}
	if m.FieldCleared(user.FieldDisplayName) {
		fields = append(fields, user.FieldDisplayName)
	}
	if m.FieldCleared(user.FieldAvatar) {
		fields = append(fields, user.FieldAvatar)
	}
	if m.FieldCleared(user.FieldReferralChannel) {
		fields = append(fields, user.FieldReferralChannel)
	}
	if m.FieldCleared(user.FieldDepartment) {
		fields = append(fields, user.FieldDepartment)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *UserMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *UserMutation) ClearField(name string) error {
	switch name {
	case user.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case user.FieldDisplayName:
		m.ClearDisplayName()
		return nil
	case user.FieldAvatar:
		m.ClearAvatar()
		return nil
	case user.FieldReferralChannel:
		m.ClearReferralChannel()
		return nil
	case user.FieldDepartment:
		m.ClearDepartment()
		return nil
	}
	return fmt.Errorf("unknown User nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *UserMutation) ResetField(name string) error {
	switch name {
	case user.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case user.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case user.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case user.FieldApplicationID:
		m.ResetApplicationID()
		return nil
	case user.FieldName:
		m.ResetName()
		return nil
	case user.FieldDisplayName:
		m.ResetDisplayName()
		return nil
	case user.FieldAvatar:
		m.ResetAvatar()
		return nil
	case user.FieldReferralChannel:
		m.ResetReferralChannel()
		return nil
	case user.FieldDepartment:
		m.ResetDepartment()
		return nil
	}
	return fmt.Errorf("unknown User field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *UserMutation) AddedEdges() []string {
	edges := make([]string, 0, 8)
	if m.bindings != nil {
		edges = append(edges, user.EdgeBindings)
	}
	if m.devices != nil {
		edges = append(edges, user.EdgeDevices)
	}
	if m.personal_role != nil {
		edges = append(edges, user.EdgePersonalRole)
	}
	if m.open_ids != nil {
		edges = append(edges, user.EdgeOpenIds)
	}
	if m.qy_wechat_user_ids != nil {
		edges = append(edges, user.EdgeQyWechatUserIds)
	}
	if m.payments != nil {
		edges = append(edges, user.EdgePayments)
	}
	if m.application != nil {
		edges = append(edges, user.EdgeApplication)
	}
	if m.organization_users != nil {
		edges = append(edges, user.EdgeOrganizationUsers)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *UserMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case user.EdgeBindings:
		ids := make([]ent.Value, 0, len(m.bindings))
		for id := range m.bindings {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeDevices:
		ids := make([]ent.Value, 0, len(m.devices))
		for id := range m.devices {
			ids = append(ids, id)
		}
		return ids
	case user.EdgePersonalRole:
		if id := m.personal_role; id != nil {
			return []ent.Value{*id}
		}
	case user.EdgeOpenIds:
		ids := make([]ent.Value, 0, len(m.open_ids))
		for id := range m.open_ids {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeQyWechatUserIds:
		ids := make([]ent.Value, 0, len(m.qy_wechat_user_ids))
		for id := range m.qy_wechat_user_ids {
			ids = append(ids, id)
		}
		return ids
	case user.EdgePayments:
		ids := make([]ent.Value, 0, len(m.payments))
		for id := range m.payments {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeApplication:
		if id := m.application; id != nil {
			return []ent.Value{*id}
		}
	case user.EdgeOrganizationUsers:
		ids := make([]ent.Value, 0, len(m.organization_users))
		for id := range m.organization_users {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *UserMutation) RemovedEdges() []string {
	edges := make([]string, 0, 8)
	if m.removedbindings != nil {
		edges = append(edges, user.EdgeBindings)
	}
	if m.removeddevices != nil {
		edges = append(edges, user.EdgeDevices)
	}
	if m.removedopen_ids != nil {
		edges = append(edges, user.EdgeOpenIds)
	}
	if m.removedqy_wechat_user_ids != nil {
		edges = append(edges, user.EdgeQyWechatUserIds)
	}
	if m.removedpayments != nil {
		edges = append(edges, user.EdgePayments)
	}
	if m.removedorganization_users != nil {
		edges = append(edges, user.EdgeOrganizationUsers)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *UserMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case user.EdgeBindings:
		ids := make([]ent.Value, 0, len(m.removedbindings))
		for id := range m.removedbindings {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeDevices:
		ids := make([]ent.Value, 0, len(m.removeddevices))
		for id := range m.removeddevices {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeOpenIds:
		ids := make([]ent.Value, 0, len(m.removedopen_ids))
		for id := range m.removedopen_ids {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeQyWechatUserIds:
		ids := make([]ent.Value, 0, len(m.removedqy_wechat_user_ids))
		for id := range m.removedqy_wechat_user_ids {
			ids = append(ids, id)
		}
		return ids
	case user.EdgePayments:
		ids := make([]ent.Value, 0, len(m.removedpayments))
		for id := range m.removedpayments {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeOrganizationUsers:
		ids := make([]ent.Value, 0, len(m.removedorganization_users))
		for id := range m.removedorganization_users {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *UserMutation) ClearedEdges() []string {
	edges := make([]string, 0, 8)
	if m.clearedbindings {
		edges = append(edges, user.EdgeBindings)
	}
	if m.cleareddevices {
		edges = append(edges, user.EdgeDevices)
	}
	if m.clearedpersonal_role {
		edges = append(edges, user.EdgePersonalRole)
	}
	if m.clearedopen_ids {
		edges = append(edges, user.EdgeOpenIds)
	}
	if m.clearedqy_wechat_user_ids {
		edges = append(edges, user.EdgeQyWechatUserIds)
	}
	if m.clearedpayments {
		edges = append(edges, user.EdgePayments)
	}
	if m.clearedapplication {
		edges = append(edges, user.EdgeApplication)
	}
	if m.clearedorganization_users {
		edges = append(edges, user.EdgeOrganizationUsers)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *UserMutation) EdgeCleared(name string) bool {
	switch name {
	case user.EdgeBindings:
		return m.clearedbindings
	case user.EdgeDevices:
		return m.cleareddevices
	case user.EdgePersonalRole:
		return m.clearedpersonal_role
	case user.EdgeOpenIds:
		return m.clearedopen_ids
	case user.EdgeQyWechatUserIds:
		return m.clearedqy_wechat_user_ids
	case user.EdgePayments:
		return m.clearedpayments
	case user.EdgeApplication:
		return m.clearedapplication
	case user.EdgeOrganizationUsers:
		return m.clearedorganization_users
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *UserMutation) ClearEdge(name string) error {
	switch name {
	case user.EdgePersonalRole:
		m.ClearPersonalRole()
		return nil
	case user.EdgeApplication:
		m.ClearApplication()
		return nil
	}
	return fmt.Errorf("unknown User unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *UserMutation) ResetEdge(name string) error {
	switch name {
	case user.EdgeBindings:
		m.ResetBindings()
		return nil
	case user.EdgeDevices:
		m.ResetDevices()
		return nil
	case user.EdgePersonalRole:
		m.ResetPersonalRole()
		return nil
	case user.EdgeOpenIds:
		m.ResetOpenIds()
		return nil
	case user.EdgeQyWechatUserIds:
		m.ResetQyWechatUserIds()
		return nil
	case user.EdgePayments:
		m.ResetPayments()
		return nil
	case user.EdgeApplication:
		m.ResetApplication()
		return nil
	case user.EdgeOrganizationUsers:
		m.ResetOrganizationUsers()
		return nil
	}
	return fmt.Errorf("unknown User edge %s", name)
}

// WechatOpenIDMutation represents an operation that mutates the WechatOpenID nodes in the graph.
type WechatOpenIDMutation struct {
	config
	op            Op
	typ           string
	id            *uuid.UUID
	created_at    *time.Time
	updated_at    *time.Time
	deleted_at    *time.Time
	open_id       *string
	platform      *wechatopenid.Platform
	union_id      *string
	clearedFields map[string]struct{}
	user          *string
	cleareduser   bool
	done          bool
	oldValue      func(context.Context) (*WechatOpenID, error)
	predicates    []predicate.WechatOpenID
}

var _ ent.Mutation = (*WechatOpenIDMutation)(nil)

// wechatopenidOption allows management of the mutation configuration using functional options.
type wechatopenidOption func(*WechatOpenIDMutation)

// newWechatOpenIDMutation creates new mutation for the WechatOpenID entity.
func newWechatOpenIDMutation(c config, op Op, opts ...wechatopenidOption) *WechatOpenIDMutation {
	m := &WechatOpenIDMutation{
		config:        c,
		op:            op,
		typ:           TypeWechatOpenID,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withWechatOpenIDID sets the ID field of the mutation.
func withWechatOpenIDID(id uuid.UUID) wechatopenidOption {
	return func(m *WechatOpenIDMutation) {
		var (
			err   error
			once  sync.Once
			value *WechatOpenID
		)
		m.oldValue = func(ctx context.Context) (*WechatOpenID, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().WechatOpenID.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withWechatOpenID sets the old WechatOpenID of the mutation.
func withWechatOpenID(node *WechatOpenID) wechatopenidOption {
	return func(m *WechatOpenIDMutation) {
		m.oldValue = func(context.Context) (*WechatOpenID, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m WechatOpenIDMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m WechatOpenIDMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of WechatOpenID entities.
func (m *WechatOpenIDMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *WechatOpenIDMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *WechatOpenIDMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().WechatOpenID.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *WechatOpenIDMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *WechatOpenIDMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the WechatOpenID entity.
// If the WechatOpenID object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WechatOpenIDMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *WechatOpenIDMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *WechatOpenIDMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *WechatOpenIDMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the WechatOpenID entity.
// If the WechatOpenID object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WechatOpenIDMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *WechatOpenIDMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *WechatOpenIDMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *WechatOpenIDMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the WechatOpenID entity.
// If the WechatOpenID object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WechatOpenIDMutation) OldDeletedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *WechatOpenIDMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[wechatopenid.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *WechatOpenIDMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[wechatopenid.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *WechatOpenIDMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, wechatopenid.FieldDeletedAt)
}

// SetOpenID sets the "open_id" field.
func (m *WechatOpenIDMutation) SetOpenID(s string) {
	m.open_id = &s
}

// OpenID returns the value of the "open_id" field in the mutation.
func (m *WechatOpenIDMutation) OpenID() (r string, exists bool) {
	v := m.open_id
	if v == nil {
		return
	}
	return *v, true
}

// OldOpenID returns the old "open_id" field's value of the WechatOpenID entity.
// If the WechatOpenID object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WechatOpenIDMutation) OldOpenID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOpenID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOpenID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOpenID: %w", err)
	}
	return oldValue.OpenID, nil
}

// ResetOpenID resets all changes to the "open_id" field.
func (m *WechatOpenIDMutation) ResetOpenID() {
	m.open_id = nil
}

// SetUserID sets the "user_id" field.
func (m *WechatOpenIDMutation) SetUserID(s string) {
	m.user = &s
}

// UserID returns the value of the "user_id" field in the mutation.
func (m *WechatOpenIDMutation) UserID() (r string, exists bool) {
	v := m.user
	if v == nil {
		return
	}
	return *v, true
}

// OldUserID returns the old "user_id" field's value of the WechatOpenID entity.
// If the WechatOpenID object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WechatOpenIDMutation) OldUserID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserID: %w", err)
	}
	return oldValue.UserID, nil
}

// ResetUserID resets all changes to the "user_id" field.
func (m *WechatOpenIDMutation) ResetUserID() {
	m.user = nil
}

// SetPlatform sets the "platform" field.
func (m *WechatOpenIDMutation) SetPlatform(w wechatopenid.Platform) {
	m.platform = &w
}

// Platform returns the value of the "platform" field in the mutation.
func (m *WechatOpenIDMutation) Platform() (r wechatopenid.Platform, exists bool) {
	v := m.platform
	if v == nil {
		return
	}
	return *v, true
}

// OldPlatform returns the old "platform" field's value of the WechatOpenID entity.
// If the WechatOpenID object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WechatOpenIDMutation) OldPlatform(ctx context.Context) (v wechatopenid.Platform, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPlatform is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPlatform requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPlatform: %w", err)
	}
	return oldValue.Platform, nil
}

// ResetPlatform resets all changes to the "platform" field.
func (m *WechatOpenIDMutation) ResetPlatform() {
	m.platform = nil
}

// SetUnionID sets the "union_id" field.
func (m *WechatOpenIDMutation) SetUnionID(s string) {
	m.union_id = &s
}

// UnionID returns the value of the "union_id" field in the mutation.
func (m *WechatOpenIDMutation) UnionID() (r string, exists bool) {
	v := m.union_id
	if v == nil {
		return
	}
	return *v, true
}

// OldUnionID returns the old "union_id" field's value of the WechatOpenID entity.
// If the WechatOpenID object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WechatOpenIDMutation) OldUnionID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUnionID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUnionID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUnionID: %w", err)
	}
	return oldValue.UnionID, nil
}

// ClearUnionID clears the value of the "union_id" field.
func (m *WechatOpenIDMutation) ClearUnionID() {
	m.union_id = nil
	m.clearedFields[wechatopenid.FieldUnionID] = struct{}{}
}

// UnionIDCleared returns if the "union_id" field was cleared in this mutation.
func (m *WechatOpenIDMutation) UnionIDCleared() bool {
	_, ok := m.clearedFields[wechatopenid.FieldUnionID]
	return ok
}

// ResetUnionID resets all changes to the "union_id" field.
func (m *WechatOpenIDMutation) ResetUnionID() {
	m.union_id = nil
	delete(m.clearedFields, wechatopenid.FieldUnionID)
}

// ClearUser clears the "user" edge to the User entity.
func (m *WechatOpenIDMutation) ClearUser() {
	m.cleareduser = true
	m.clearedFields[wechatopenid.FieldUserID] = struct{}{}
}

// UserCleared reports if the "user" edge to the User entity was cleared.
func (m *WechatOpenIDMutation) UserCleared() bool {
	return m.cleareduser
}

// UserIDs returns the "user" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UserID instead. It exists only for internal usage by the builders.
func (m *WechatOpenIDMutation) UserIDs() (ids []string) {
	if id := m.user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUser resets all changes to the "user" edge.
func (m *WechatOpenIDMutation) ResetUser() {
	m.user = nil
	m.cleareduser = false
}

// Where appends a list predicates to the WechatOpenIDMutation builder.
func (m *WechatOpenIDMutation) Where(ps ...predicate.WechatOpenID) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the WechatOpenIDMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *WechatOpenIDMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.WechatOpenID, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *WechatOpenIDMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *WechatOpenIDMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (WechatOpenID).
func (m *WechatOpenIDMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *WechatOpenIDMutation) Fields() []string {
	fields := make([]string, 0, 7)
	if m.created_at != nil {
		fields = append(fields, wechatopenid.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, wechatopenid.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, wechatopenid.FieldDeletedAt)
	}
	if m.open_id != nil {
		fields = append(fields, wechatopenid.FieldOpenID)
	}
	if m.user != nil {
		fields = append(fields, wechatopenid.FieldUserID)
	}
	if m.platform != nil {
		fields = append(fields, wechatopenid.FieldPlatform)
	}
	if m.union_id != nil {
		fields = append(fields, wechatopenid.FieldUnionID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *WechatOpenIDMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case wechatopenid.FieldCreatedAt:
		return m.CreatedAt()
	case wechatopenid.FieldUpdatedAt:
		return m.UpdatedAt()
	case wechatopenid.FieldDeletedAt:
		return m.DeletedAt()
	case wechatopenid.FieldOpenID:
		return m.OpenID()
	case wechatopenid.FieldUserID:
		return m.UserID()
	case wechatopenid.FieldPlatform:
		return m.Platform()
	case wechatopenid.FieldUnionID:
		return m.UnionID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *WechatOpenIDMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case wechatopenid.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case wechatopenid.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case wechatopenid.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case wechatopenid.FieldOpenID:
		return m.OldOpenID(ctx)
	case wechatopenid.FieldUserID:
		return m.OldUserID(ctx)
	case wechatopenid.FieldPlatform:
		return m.OldPlatform(ctx)
	case wechatopenid.FieldUnionID:
		return m.OldUnionID(ctx)
	}
	return nil, fmt.Errorf("unknown WechatOpenID field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *WechatOpenIDMutation) SetField(name string, value ent.Value) error {
	switch name {
	case wechatopenid.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case wechatopenid.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case wechatopenid.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case wechatopenid.FieldOpenID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOpenID(v)
		return nil
	case wechatopenid.FieldUserID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserID(v)
		return nil
	case wechatopenid.FieldPlatform:
		v, ok := value.(wechatopenid.Platform)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPlatform(v)
		return nil
	case wechatopenid.FieldUnionID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUnionID(v)
		return nil
	}
	return fmt.Errorf("unknown WechatOpenID field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *WechatOpenIDMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *WechatOpenIDMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *WechatOpenIDMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown WechatOpenID numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *WechatOpenIDMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(wechatopenid.FieldDeletedAt) {
		fields = append(fields, wechatopenid.FieldDeletedAt)
	}
	if m.FieldCleared(wechatopenid.FieldUnionID) {
		fields = append(fields, wechatopenid.FieldUnionID)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *WechatOpenIDMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *WechatOpenIDMutation) ClearField(name string) error {
	switch name {
	case wechatopenid.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case wechatopenid.FieldUnionID:
		m.ClearUnionID()
		return nil
	}
	return fmt.Errorf("unknown WechatOpenID nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *WechatOpenIDMutation) ResetField(name string) error {
	switch name {
	case wechatopenid.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case wechatopenid.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case wechatopenid.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case wechatopenid.FieldOpenID:
		m.ResetOpenID()
		return nil
	case wechatopenid.FieldUserID:
		m.ResetUserID()
		return nil
	case wechatopenid.FieldPlatform:
		m.ResetPlatform()
		return nil
	case wechatopenid.FieldUnionID:
		m.ResetUnionID()
		return nil
	}
	return fmt.Errorf("unknown WechatOpenID field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *WechatOpenIDMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.user != nil {
		edges = append(edges, wechatopenid.EdgeUser)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *WechatOpenIDMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case wechatopenid.EdgeUser:
		if id := m.user; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *WechatOpenIDMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *WechatOpenIDMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *WechatOpenIDMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.cleareduser {
		edges = append(edges, wechatopenid.EdgeUser)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *WechatOpenIDMutation) EdgeCleared(name string) bool {
	switch name {
	case wechatopenid.EdgeUser:
		return m.cleareduser
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *WechatOpenIDMutation) ClearEdge(name string) error {
	switch name {
	case wechatopenid.EdgeUser:
		m.ClearUser()
		return nil
	}
	return fmt.Errorf("unknown WechatOpenID unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *WechatOpenIDMutation) ResetEdge(name string) error {
	switch name {
	case wechatopenid.EdgeUser:
		m.ResetUser()
		return nil
	}
	return fmt.Errorf("unknown WechatOpenID edge %s", name)
}
